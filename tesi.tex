% vim: encoding=utf-8
% vim: fileencoding=utf-8
\documentclass[twoside,11pt,a4paper,italian,openany]{book}
\usepackage[italian]{babel}
%è safe metterlo a 1.6, con 13 pagine arrivo a 16
\linespread{1.3}
%\renewcommand{\baselinestretch}{1.6}
\usepackage[utf8]{inputenc}
\usepackage{newcent}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{comment}
\usepackage[pdftex]{graphicx}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}




\newcommand{\tv}{\texttt{TinyViz}}

\newcommand{\tos}{\texttt{TOSSIM} }

\begin{document}
\frontmatter
%\maketitle
\newlength{\centeroffset}
\setlength{\centeroffset}{-0.5\oddsidemargin}
\addtolength{\centeroffset}{0.5\evensidemargin}
\thispagestyle{empty}
%\vspace*{\stretch{1}}
\noindent\hspace*{\centeroffset}\makebox[0pt][l]{\begin{minipage}{\textwidth}
\flushright
{\fontfamily{helvet}
  {\Huge\bfseries Implementazione di un MAC energy-efficient per reti di sensori wireless}
  \noindent\rule[-1ex]{\textwidth}{5pt}\\[2.5ex]
  \flushright
  {\bfseries\Large Gabriele Renzi\\[1.5ex]
  Anno Accademico 2004/2005}
}
\end{minipage}}


\pagestyle{fancy}

\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\fancyhf{} % rimuove l’attuale contenuto dell’intestazione
             % e del pi\‘e di pagina
\fancyhead[LE,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\fancyhead[RE]{\bfseries\leftmark}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{0.5pt} % riserva spazio per la linea
\fancypagestyle{plain}{%
    \fancyhead{} % ignora, nello stile plain, le intestazioni
    \renewcommand{\headrulewidth}{0pt} % e la linea
}
\newcommand{\sink}[0]{\emph{Sink }}
\newcommand{\ack}[0]{\texttt{ACK }}

\newcommand{\req}[0]{\texttt{REQ }}
\newcommand{\nesc}[0]{\texttt{NesC }}
\clearpage
\null\vspace{\stretch{1}}
\begin{flushright}
 \emph{Ai miei genitori, che dopo tutti questi anni
       non mi hanno ancora tagliato i viveri.}
\end{flushright}
\vspace{\stretch{2}}
\mainmatter
\tableofcontents
\chapter{Introduzione}
L'intento della tesi è l'implementazione di un protocollo MAC per reti di sensori 
multihop ad hoc organizzate in un albero per la raccolta di dati.
Il protocollo DMAC è appositamente progettato per funzionare all'interno dei vincoli 
imposti da questa tipologia di reti e dall'hardware utilizzato, 
facendo uso di fasi alternate di attività/riposo per massimizzare 
il risparmio energetico e di un meccanismo di autocorrezione dello scheduling per 
ottenere buoni valori di latenza e throughput.
Per l'implementazione è stato usato il linguaggio \nesc, un dialetto del \texttt{C}
con estensioni per la concorrenza e la progrmmazione a componenti, 
appoggiandosi alla piattaforma TinyOS, un sistema operativo pensato per dispositivi embedded di questo tipo.  Il testing dell'applicazione è stato effettuato utilizzando il simulatore \tos  
e gli strumenti a corredo dello stesso, come l'interfaccia grafica \tv e strumenti 
per l'iniezione di pacchetti radio nella simulazione.



\chapter{Le reti di sensori wireless}
\begin{figure}
\caption{Un sensore wireless}
\includegraphics{img/sensore}
\end{figure}

Un sensore wireless è un dispositivo embedded che contiene una CPU, dei componenti di memoria, 
dei rilevatori ambientali  ed una ricetrasmittente. Un sensore può essere progettato per 
rilevare qualsiasi tipo di dato, dalla temperatura al movimento, ma non è pensato per l'analisi 
di questi dati, in quanto tipicamente non possiede le risorse sufficienti a fornire 
un'elaborazione complessa delle informazioni, e quindi i sensori vengono organizzati 
in reti articolate dette appunto \emph{Wireless Sensor Network} (WSN).
Una WSN è costituita da un numero molto grande di sensori, distribuiti su un territorio che può essere anche molto esteso ed i sensori non possono quindi limitarsi a trasmettere 
le informazioni raccolte verso il nodo demandato all'analisi dei dati, ma devono essere 
organizzati in percorsi multihop ad hoc, ed in particolare con una topologia caratteristica in 
cui i pacchetti vengono indirizzati dai nodi periferici verso un nodo particolare, detto \sink, 
il quale sarà costituito da un elaboratore in grado di gestire le informazioni raccolte 
in modo utile. Un'organizzazione di questo tipo viene detta \emph{data gathering tree}, 
in quanto essa assomiglia ad un albero (i nodi che rilevano i dati sono le foglie, e 
l'informazione si propaga attraverso i nodi intermedi fino alla radice), sebbene in realtà 
la rete possa essere un grafo più complesso. 
\begin{figure}
\caption{\emph{Le WSN sono organizzazioni ad hoc con routing multihop}}
\includegraphics{img/network}
\end{figure}

Le reti di sensori wireless hanno molteplici utilizzi tra i quali applicazioni in campo 
medicale,  rilevazione sismiche,  controllo industriale, localizzazione/tracking e molto altro, 
il che implica la necessità di definire soluzioni specifiche per ogni problema. 
Il protocollo implementato per questa tesi, DMAC\cite{DMAC}, è appositamente pensato per gli 
alberi di raccolta dati, e cerca di sfruttare delle euristiche per limitare sia la 
possibilità di errore nella trasmissione sia il consumo energetico, garantendo comunque una 
bassa latenza.


%nteragire con l'ambiente e per comunicare via radio. 
\chapter{Il protocollo DMAC}
\section{I problemi delle reti di sensori}
In una topologia di tipo data gathering tree, la parte più rilevante del 
traffico è costituita dal flusso di pacchetti verso il \sink, mentre le informazioni 
trasmesse nel verso opposto sono limitate a rari pacchetti di controllo.

Gli autori di \cite{DMAC} hanno dunque preso in considerazione questo punto fondamentale con 
l'obiettivo di ottenere un compromesso ottimale tra i vari elementi di interesse in una WSN,
ovvero:

\begin{itemize}

\item \emph{latenza}, in alcune situazioni, come la rilevazione in ambito medicale o 
i sistemi di allarme, è importante che le informazioni si propaghino velocemente dal nodo che le 
rileva fino al \sink

\item \emph{throughput}, alcune WSN possono produrre un traffico molto elevato in alcuni momenti,ed è necessario che tutti i dati vengano ricevuti nel minor tempo possibile 
%&iad esempio nei sistemi di controllo in ambito industriale

\item \emph{energia}, i sensori sono tipicamente dispositivi a batterie, ed in configurazioni
in cui il numero di questi dispositivi è molto alto non è fattibile la sostituzione/ricarica ad 
intervalli frequenti, quindi è necessario ottmizzare i consumi.

\end{itemize}

Il punto principale da cui parte l'analisi del DMAC è l'energia, in quanto si tratta di un 
vincolo particolarmente importante. DMAC, come già altri protocolli\cite{SMAC} 
progettati in precedenza, parte dalla considerazione che il traffico in una WSN è molto leggero 
per la maggior parte del tempo, e che quindi è 
possibile ed auspicabile che i nodi non coinvolti nel trasporto di dati rimangano spenti 
quanto più possibile, in modo da risparmiare energia. 
Questo approccio è in contrasto però con l'intento di massimizzare latenza e throughput, 
perché ogni nodo che si trovi a più di un hop dal \sink dovrà attendere che il nodo successivo 
nel suo percorso entri in uno stato attivo. Questo approccio non sembra quindi essere in grado 
di scalare a reti con molti nodi. 
Un alternativa è quella di mettere i nodi in uno stato di \emph{power saving} la 
maggior parte del tempo e di portarli in uno stato attivo quando ricevono una richiesta di 
comunicazione, ma lo spreco di energia in questo approccio è comunque molto maggiore di quello 
relativo ad uno stato di spegnimento effettivo del componente radio. 

\section{Staggered wakeup nel DMAC}
Per massimizzare il risparmio di energia senza peggiorare troppo la latenza, 
il protocollo DMAC utilizza un meccanismo di scheduling a tre stati per i nodi, 
con l'aggiunta di un meccanismo di \emph{staggered wakeup} per cui i nodi che si trovano ad un 
hopcount maggiore dal \sink entrano nel ciclo di scheduling prima di quelli più vicini, un 
approccio che avrebbe numerosi vantaggi.
\begin{figure}
\includegraphics{img/wakeup}
\caption{\emph{Nel DMAC I nodi ad un livello hanno un ciclo sfasato rispetto ai livelli vicini}}
\end{figure} 
 Anzitutto il tempo di attesa per il forwarding di un
pacchetto è molto limitato, perché quando un nodo si trova in una fase attiva il mote seguente
nel suo multihop path verso il \sink sarà anch'esso attivo, mentre un pacchetto che si trova 
a parecchi hop di distanza sarà spento. 
Con il procedere del pacchetto lungo l'hop path i nodi ancora da percorrere entrano uno alla 
volta in uno stato di attività, mentre quelli che hanno già trasmesso possono tornare inattivi.
\`E facile notare che questo approccio è implicitamente scalabile, in quanto all'aumentare della profondità dell'albero non c'è un aumento dell'overhead, ne' un peggioramento dal punto di vista energetico, in quanto un nodo che si trovi distante dall'azione resterà spento finché il 
pacchetto non gli sia vicino.
Allo stesso tempo, il fatto che il pacchetto si propaghi in modo "lineare" permette di far si 
che tutti i nodi nel percorso verso il \sink  siano in grado di variare tempestivamente il 
proprio \emph{duty cycle} scheduling se necessario, mentre i nodi non coinvolti nella trasmissione possono mantenere il loro ciclo di attivazione/spegnimento originario. 
Va notato che questo meccanismo ha senso solamente in una certa classe di configurazioni 
delle WSN, i \emph{data gathering tree}, in quanto la comunicazione dalla radice alle foglie 
risulta penalizzata, quindi il protocollo è adatto solo se i pacchetti di controllo 
inviati dal \sink sono rari. 

\section{Stati nel DMAC}
Un problema che rimane è quello relativo alla contesa del canale, anche se ovviamente il fatto 
che livelli differenti si attivino in momenti differenti riduce le dimensioni del problema.
Per far si che il messaggio arrivi correttamente e che le interferenze tra i differenti livelli 
dell'albero siano minimizzate, ogni \emph{mote} può essere in tre stati differenti, 
suddividendo il  periodo di funzionamento attivo in una coppia di periodi,
rispettivamente di ricezione e di invio.

Nello stato di ricezione un nodo attende di ricevere un pacchetto, che chiameremo \req,
ed in caso questo accada esso manda un \ack al mittente. 
Il nodo ricevente \emph{non inoltra} i dati in questa 
fase ma li immagazzina in una coda fino a che non si trovi nel suo stato di invio. 
Quando il nodo entra a sua volta nello stato di invio non fa altro che inoltrare il pacchetto 
che aveva ricevuto precendetemente ed attendere il relativo \ack.  

Gli stati si susseguono nell'ordine \emph{ricezione, invio, inattività}, il che implica
che un nodo ad $n$ hop dal sink si troverà in uno stato di invio quando il nodo ad $n-1$ 
hop si trova in stato di ricezione. 
Nel caso in cui l'\ack  non venga ricevuto il pacchetto 
inoltrato precedentemente rimane nella coda locale in attesa dello slot di invio seguente. 
Opportune regole di drop possono essere introdotte in questo schema, ad esempio sarebbe 
ragionevole abbandonare il tentativo di invio dopo che per un certo numero di volte si è 
inoltrato un pacchetto senza ricevere il relativo \ack. 
 
Nel periodo di inattività i nodi spengono completamente la radio, e quindi sono isolati dalle 
trasmissioni, ma l'organizzazione temporale fa si che essi non stiano aumentando la latenza ne' 
abbattendo il throughput, visto che i nodi vicini con i quali potrebbero comunicare sono 
anch'essi in uno stato di analogo. 

I periodi di invio e ricezione hanno una stessa durata $\mu$ che deve essere lunga abbastanza 
affinché un pacchetto possa essere inviato, e  sia possibile per il mittente ricevere un  
 \ack, il che è ovviamente dipendente dalla tipologia di dispositivi. 
 
Dunque ad ogni tempo $t$ teoricamente saranno solamente i nodi ad un certo livello a 
trasmettere, limitando la contesa per il canale. 

Il periodo di inattività ha una durata nettamente maggiore del periodo attivo, anche se nel 
documento originale non c'è una indicazione chiara a riguardo, tranne il fatto che per le 
simulazioni effettuate dagli autori essi hanno usato un tempo di circa $18\mu$, il che è stato replicato in questa implementazione. 
Questo tempo può variare in caso \emph{burst} di dati, come vedremo in seguito.

Un meccanismo di questo tipo ha bisogno evidentemente di una sincronizzazione molto precisa, ma 
esistono algoritmi validi\cite{sync} che permettono di portare l'errore di sincronizzazione 
ad un millesimo del tempo $\mu$, quindi questo non rappresenta un problema. 

\section{Adattatività del DMAC}
Nella maggior parte delle WSN è probabile che un nodo che raccolga informazioni attraversi dei
periodi di \emph{burst} in cui esso ha parecchie informazioni da inoltrare, e si può notare che 
con il meccanismo appena descritto un'informazione che abbia bisogno di due pacchetti avrebbe 
bisogno di almeno $20$ slot di tempo piuttosto che di $2$ (il caso in cui i nodi fossero 
costantemente attivi), il che significa aumentare notevolmente la latenza della rete. 
Il protocollo prevede quindi dei meccanismi di autoregolazione del duty cycle basati su una flag 
\texttt{more-to-send} presente nell'header dei pacchetti. 
Se un nodo ha diversi pacchetti da spedire oppure se ha ricevuto un pacchetto con questa flag
già impostata, esso la imposterà a sua volta nei pacchetti in uscita in modo in modo da 
indicare al nodo seguente che ci sono altri dati in arrivo, e che esso dovrà prepararsi a 
riceverli. Il meccanismo è chiaramente ricorsivo e fa si che l'informazione si propaghi fino 
al \sink sulla base di sincronizzazioni locali, il che significa che nel caso un pacchetto dal 
nodo $X$ al nodo $Y$ vada perso o sia danneggiato nessuno dei nodiche si trovano sull'hop path da
$Y$ al \sink verrà informato della necessità di cambiare il proprio duty cycle, ed essi quindi 
non sprecheranno risorse inutilmente rimanendo attivi in un periodo in cui non potrebbero 
comunque ricevere altri dati. 
\begin{figure}
\includegraphics{img/moretosend}
\caption{\emph{I nodi intensificano il duty cycle quando ricevono un pacchetto MTS}}
\end{figure}

Va sottolineato che nel DMAC, quando un nodo riceve un pacchetto \texttt{more-to-send} esso non 
rimane in uno degli stati attivi nello slot immediatamente seguente, entra invece in uno stato di
inattività ma riducendone la durata a  
$3\mu$ per poi tornare nello stato di ricezione. Questa attesa è necessaria affinché il 
pacchetto abbia il tempo di propagarsi tra i nodi seguenti, senza che ci siano collisioni con i
segnali inviati dai livelli precedenti. 
% pippa sul fatto che potebber essere sprecato un periodo
% pippa sul data prediction

Gli autori del DMAC teorizzano anche un approccio alternativo in cui il pacchetto non contiene 
una flag MTS,  ed il processo di scheduling è leggermente differente. 
Implementare questa variazione richiederebbe l'aggiunta di un nuovo stato, di 
nuove regole di transizione e l'eliminazione di un paio di righe nelle routine di invio dei dati,
ma sebbene questa modifica non incida molto sulla maggior parte del codice \nesc non offre dei 
meccanismi di astrazione adatti a permettere il riuso del codice in questa situazione, e dato 
che l'unico approccio possibile sarebbe stato quello di aggiungere ancora altre macro 
per la compilazione condizionale si è preferito non farlo per non rendere i sorgenti troppo 
intricati. 



\chapter{La piattaforma TinyOS}

\section{Un sistema operativo per WS}
Con la diffusione di sensori sempre più complessi e vari, esattamente come per 
l'informatica domestica, sono sorte la possibilità e la necessità di gestire i
componenti ad un livello più alto di astrazione, ma dovendo comunque conciliare 
i vantaggi dell'astrazione (portabilità, velocità nello sviluppo) con le pesanti 
limitazioni nell'hardware. 

TinyOS\cite{tinyos} rappresenta in questo senso un moderno sistema operativo per WS, 
che fornisce meccanismi molto utili per la realizzazione di applicazioni, permettendo 
ad un tempo di raggiungere i vantaggi dell'astrazione ma anche lasciando aperta la possibilità 
di usufruire delle funzionalità specifiche di ogni hardware in modo da non sprecare risorse. 

Tra le funzionalità che TinyOS offre ci sono
\begin{itemize}

\item{astrazione hardware stratificata, con possibilità di lavorare ad un qualunque livello}

\item{vari meccanismi per la concorrenza }

\item{gestione della memoria e dello scheduling}

\item{un linguaggio di sviluppo (\nesc) che supporti direttamente tutto questo}
\end{itemize}

TinyOS è software open source, disponibile a tutti e con una comunità in crescita.
Esso offre inoltre alcuni strumenti a corredo interessanti, tra i quali sono presenti 
simulatori, visualizzatori, database, ed interfacce con vari linguaggi di programmazione. 


\section{\nesc un linguaggio per dispositivi wireless embedded}

Sebbene il C sia ormai lo standard de facto come \emph{system language} esso è per molti versi 
un linguaggio vecchio, che sebbene abbia conosciuto diverse revisioni mantiene comunque una 
netta mancanza per costrutti di alto livello. 
\nesc è basato sul C, sia a livello sintattico che a livello semantico. 
In effetti il compilatore \nesc è effettivamente implementato come un frontend per il noto compilatore multipiattaforma GCC \cite{nesc}.

\nesc estende però il C in varie direzioni ortogonali, che rispecchiano da un lato le 
funzionalità di TinyOS e dall'altro le necessità dell'hardware particolare su cui esso deve 
funzionare. 

\subsection{Task}
TinyOS fornisce alcune primitive per la concorrenza che sono replicate nel design di \nesc.
Ogni dispositivo può avere in esecuzione differenti \emph{task}, i quali vengono attivati 
secondo un meccanismo di scheduling non preemptive, quindi funzionando finché la funzione 
associata non raggiunge un \texttt{return}. 
Si tratta di un meccanismo di concorrenza a stato condiviso in cui 
i task possono comunicare solamente tramite variabili condivise, in modo analogo a 
\emph{pthread} o ai thread in Java/.NET,  ma poiché i task non sono in grado di 
interrompersi l'un l'altro non si presentano gli stessi problemi.

Un task può però essere interrotto da un evento asincrono, il che significa che l'evento 
potrebbe intervenire cambiando i dati manipolati dal task e generaqndo delle inconsistenze.
Per minimizzare questo problema ogni programma scritto in  \nesc è soggetto ad 
un'analisi globale che è teoricamente in grado di individuare possibili race condition e 
condurre l'autore alla loro eliminazione, riducendo il numero di bug. 
Questo meccanismo no è però infallibile, e può sbagliare producendo false positive.


\subsection{Eventi}
Lo scheduler di TinyOS può sempre decidere di interrompere il funzionamento di un task 
se riceve un evento hardware. 
Per modellare questi casi \nesc offre il meccanismo degli eventi, 
che sono speciali funzioni annotate come tali e che vengono richiamate in numerosi 
casi, l'arrivo di un segnale radio, l'avvio di un timer, l'inizio della ricezione di dati da un sensore etc...
Gli eventi non sono necessariamente asincroni, e tipicamente eventi di bassa priorità (per esempio il segnalare che un pacchetto è stato inviato) non lo sono.
\`E possibile definire propri eventi prependendo la keyword \texttt{event} ad una qualsiasi 
funzione, a differenza dei task che possono essere solamente a funzioni \texttt{void}.

Poiché un evento asincrono potrebbe interrompere una funzione in un punto qualsiasi della sua esecuzione, \nesc offre un meccanismo per garantire che un blocco di codice venga eseguito in 
maniera atomica,  permettendo di annotare una qualsiasi variabile come \texttt{atomic} o 
di inserire un blocco di codice indicato come tale, in maniera simile a \texttt{synchronized} 
in Java.


 

\subsection{Componenti ed Interfacce}
TinyOS come molti altri SO usa e fornisce delle interfacce per rappresentare gli oggetti del 
sistema (layer di rete, driver etc...). 
Mentre però in molte piattaforme classiche (Win32, Linux, BSD) ciò è fatto informalmente 
usando il linguaggio C, \nesc è stato esteso per supportare sintatticamente l'idea di 
programmazione a componenti. 
\begin{figure}
\includegraphics{img/moduli}
\caption{\emph{I moduli in \nesc richiedono e forniscono interfacce, tramite il wiring esse possono essere combinate in modi differenti}}
\end{figure}
Un'interfaccia dichiara di fornire un certo numero di 
\begin{itemize}

\item{eventi, il che significa che un componente che usi l'interfaccia deve fornire appropriati
handler} 

\item{comandi, cioè procedure o funzioni che verranno chiamate dal componente che usa l'interfaccia}
\end{itemize}

Un componente può implementare una o più interfacce (o implementare un'interfaccia più volte 
con nomi diversi, il che fornisce una qualche similarità con la programmazione ad oggetti), 
ed è composto principalmente da due parti, una di configurazione 
(dichiarazione di componenti ed interfacce usati) ed una di implementazione.
La configurazione è il cuore della parte \emph{Component-Oriented} di \nesc, in quanto è 
il punto in cui viene effettuata l'associazione tra componenti ed interfacce, operazione indicata
 come \emph{wiring}, offrendo una grande flessibilità. 
La parte di implementazione contiene riferimenti solamente ai nomi indicati nella configurazione
, rendendo facilmente sostituibili i componenti.
Essa contiene poi il codice di comandi, task ed eventi, e può avere un 
certo numero di variabili globali accessibili da tutte le funzioni del componente ma non 
dall'esterno. 

Per massimizzare il riuso e la semplicità di programmazione componenti ed interfacce possono 
essere parametrizzati, un qualsiasi valore può essere 
incluso in fase di configurazione effettuando una sorta di \emph{currying} dell'interfaccia. 
Un esempio è quello delle interfacce per la comunicazione radio, dove è possibile specificare 
il tipo di segnale AM che si vuole utilizzare una volta sola durante il wiring senza doverlo specificare ogni volta che si usano i comandi forniti dalle interfacce. 
In versioni più recenti di \nesc è possibile avere anche type parameter, ma con la versione della piattaforma usata in questa tesi ciò non è stato possibile. 



\subsection{Staticità}

\nesc è un linguaggio completamente statico, nel senso che la maggior parte delle attività 
possibili è fatta a compile time. Con ciò non si intende solo un semplice type checking sui 
moduli compilativi, ma anche una gestione statica della memoria ed altre operazioni. 


\nesc fa uso di \emph{whole program analisys and optimization} (WPA/WPO) per raggiungere alte
performance tramite ottimizzazioni interprocedurali, constant propagation, dead code 
elimination etc (ma esse sono in realtà solo possibili in via teorica, 
al momento molto poco di ciò è implementato).
Allo stesso tempo grazie alla WPA il compilatore può effettuare il controllo sulle race condition
di cui si è già discusso. 



\section{\tos, un simulatore per PC}
\tos\cite{TOSSIM} è un simulatore per personal computer  in grado di far funzionare lo 
stesso codice \nesc che è stato scritto per i dispositivi embedded. 
I vantaggi di questo approccio sono nel fatto che il codice può essere scritto, 
debuggato e testato su una normale macchina casalinga, e poi essere trasportato 
senza cambiamenti su un dispositivo reale. 
\tos è in sostanza una libreria che viene connessa in fasi di link con il codice \nesc 
tradotto in codice C, e che fornisce il \texttt{main()} ed altro, producendo un 
eseguibile nativo per ogni applicazione TinyOS.

Purtroppo questo approccio molto semplice ha uno svantaggio, poiché si avrà sempre 
lo stesso codice che funziona su tutti i nodi, senza la possibilità di programmare diversamente nodi che hanno funzionalità differenti. 

\tos è in grado di accettare in input un modello delle probabilità di perdita di pacchetti 
tra due nodi qualunque, o di usare dei modelli euristici predefiniti, ma non comprende ne' 
informazioni topologiche, ne' modelli di alto livello, i quali possono però essere sempre 
definiti in termini di probabilità di perdita su un qualsiasi arco.
Allo scopo di definire questi modelli, sono stati creati vari strumenti, tra i quali 
\texttt{LossyBuilder}, un programma in grado di generare file di testo rappresentanti 
la distribuzione di una rete di nodi in topologia a griglia.


\tos fornisce inoltre un'interfaccia modellata sui meccanismi di TinyOS, cioè comandi ed eventi, 
che gli permette di interoperare con dispositivi esterni, permettendo così l'implementazione 
in componenti separati di tutta una serie di funzionalità come l'analisi dei segnali, 
la visualizzazione di una topologia, l'iniezione di pacchetti radio e di informazioni per 
i sensori etc.. 
Il principale strumento pr fare questo è \tv, un ambiente grafico realizzato in Java che 
astrae i meccanismi di base di questa 
interazione con \tos esponendoli tramite un'interfaccia semplificata ad una serie 
di plugin caricabili a runtime.  
La distribuzione di TinyOS comprende un insieme variegato di plugin che 
però sono purtroppo in molti casi non mantenuti e non funzionano. Il codice di \tv è 
in generale eccelso e mal documentato. 

Durante la realizzazione di questa tesi è avvenuta una riscrittura di 
questo ambiente che lo ha portato ad essere fondato su jython\cite{tython}, 
cioè un interprete python per JVM, il che permette la realizzazione di semplici script 
(ma anche programmi complessi).  
 

\chapter{L'implementazione}
\section{Visione d'insieme}
Per realizzare l'applicazione il codice è stato strutturato in due differenti moduli più 
una libreria elementare in \texttt{C} per la gestione di una coda.

Il primo modulo si occupa dell'individuazione delle informazioni relative alla topologia, 
mantenendo per ogni nodo informazioni sulla sua distanza dal \sink e su quale sia il prossimo 
nodo nel multihop path.  
Quando l'albero è stato mappato inizia il loop principale dei mote, che è una 
semplice macchina a stati finiti con tre stati implementata con degli \texttt{if/else}.
Il codice fa uso di una coda per i pacchetti da inoltrare implementata nel file \texttt{MyQueue.h}, realizzata tramite una semplice lista collegata.
Era nelle intenzioni di realizzare un componente \texttt{Queue} usando dei type parameter, 
il che avrebbe reso possibile il riuso dello stesso in situazioni in cui si dovessero gestire 
code composte da pacchetti differenti (o da qualsiasi altro tipo), ma \nesc nella versione 
utilizzata non permette di 
realizzare interfacce parametrizzate tramite tipi, e quindi sarebbe stato necessario ricorrere 
ad un approccio non type safe, ad esempio usando dei cast da e verso \texttt{void *}, che  
avrebbe a sua volta introdotto complicazioni derivanti dalla necessità di passare la dimensione 
della struttura ad ogni operazione, aggiungendo poca utilità a questa applicazione e portando  
una enorme complicazione inutile.
All'interno del codice si fa dunque riferimento esplicito ai tipi 
definiti nel resto del programma (\texttt{DataMsg} definito in \texttt{DMac.h}).



\newcommand{\treedata}{\texttt{TreeData}}
\newcommand{\tree}{\texttt{Tree}}

\section{Il componente \treedata}
La mappatura dell'albero è affidata ad un apposito componente \tree, che implementa l'interfaccia
\texttt{StdControl} e ne definisce una sua, \treedata.
L'interfaccia \texttt{StdControl} è un'interfaccia generica per un componente \nesc, 
la quale fornisce comandi per attivare o disattivare un componente
 ed avviare operazioni specifiche.
L'attivazione di \tree porta all'attivazione del componente di rete, \texttt{GenericComm}, 
il quale fornisce implementazioni delle interfacce di basso livello per l'invio e la ricezione 
di pacchetti. 
Queste interfacce lavorano in termini di una \texttt{struct TOS\_Msg} la quale possiede un 
campo dedicato al contenimento di una struttura definita dall'utente, che in questo
componente contiene solo due campi: il numero sequenziale dell'hop count e l'indirizzo del mittente. 
Quando viene richiamato il comando \texttt{StdControl.start()} il modulo inizio la mappatura 
dell'albero seguendo un processo molto semplice, a partire dal \sink. 
Questo nodo invia un segnale broadcast indicando il suo indirizzo di rete ed il numero di hop 
necessari a raggiungerlo ($1$, per il \sink). Ogni nodo che riceve questo messaggio provvede 
poi ad inoltrarlo a sua volta, sempre come segnale broadcast, aggiornando le
informazioni su mittente ed hop count. 
Quando un nodo riceve un messaggio viene segnalato l'evento 
\texttt{ReceiveMsg.receive()}, ed è li che si trova la vera logica del componente. 
Infatti il codice si occupa di impostare appropriatamente delle variabili globali 
(a livello di componente) che rappresentano l'hop count ed il prossimo nodo nel percorso verso 
il \sink, ma solamente nel caso che il messaggio ricevuto indichi la possibilità di raggiungerlo
in un numero di hop minore rispetto a quello registrato precedentemente. 

Il Sink, dal canto suo, continua ad inviare pacchetti ad intervalli regolari (cioè ogni volta 
che viene segnalato \texttt{SinkTimer.fired()}, in modo da evitare eventuali errori dovuti alla 
perdita di pacchetti o a problemi di trasmissione.
Il processo continua fino a che il componente non viene fermato, tramite 
\texttt{StdControl.stop()}, ed è il codice in \texttt{DmacM.nc} che si occupa di questo.

Le informazioni immagazzinate da questo componente sono accessibili tramite i due comandi 
definiti nell'interfaccia \treedata, e cioè \texttt{getHopToSink()} e \texttt{getNextHopToSink()}. 
Alcune note aggiuntive su questa implementazione:
\begin{itemize}
\item{L'implementazione non specifica quale nodo sia il \sink, è il codice che usa questo 
componente che può decidere quale sia il nodo che deve iniziare la mappatura dell'albero, 
tramite \texttt{StdControl.start()}, il che rende il modulo più flessibile}

\item{In realtà l'albero tracciato in questo modo non implica che un nodo al livello $n$ sia in 
grado di inviare messaggi al livello $n-1$, perché è possibile che ci siano delle asimmetrie 
nelle capacità di invio/ricezione; \tos supporta questo tipo di topologie, in quanto si 
occupa solamente di percentuali di errore tra due archi generici, e gli archi $(a,b)$ e $(b,a)$ 
vengono considerati differenti. Per questa simulazione non ci siamo occupati di questo problema,
assumendo che se la comunicazione può avvenire in un verso essa funzioni anche nell'altro. 
D'altro canto sarebbe relativamente semplice cambiare una parte dell'implementazione del modulo 
\tree utilizzando un algoritmo di mappatura differente mantenendo comunque la stessa 
interfaccia.}

\item{In questo codice, ed anche nel codice del resto del programma, si può notare la presenza 
di una variabile di tipo \texttt{TOS\_Msg} che è dichiarata globalmente.
Ciò è necessario poiché il meccanismo di invio di un pacchetto radio è organizzato in due fasi, 
la prima viene attivata tramite il comando \texttt{SendMsg.send()}, che nonostante il nome 
fuorviante \emph{non} invia il messaggio ma si limita a metterlo in una una coda di invio.
La seconda fase viene effettuata dal layer sottostante, che una volta inviato il pacchetto 
richiama l'evento \texttt{SendMsg.sendDone()}. 
Se quindi la variabile che rappresenta il messaggio fosse dichiarata come locale in 
\texttt{SinkTimer.fired()} essa verrebbe deallocata quando la funzione terminasse,  
ed al momento dell'effettivo invio il layer sottostante si troverebbe un riferimento 
ad una zona di memoria non valida. }
\end{itemize}

Infine, va detto che l'evento \texttt{SendMsg.sendDone()} viene richiamato passandogli un 
argomento che  dovrebbe indicare se l'invio è avvenuto correttamente o meno. 
Nel simulatore questo valore non è affidabile, in quanto il valore \texttt{SUCCESS}, di ovvio 
significato, è cablato nel codice senza alcuna condizione. 
Purtroppo sembra che in \tos siano state prese numerose scorciatoie di questo tipo, il che 
rende lo sviluppo usando il simulatore decisamente più problematico. 


\section{Il cuore dell'applicazione}
Il componente Dmac implementa l'algoritmo descritto in \cite{DMAC} sebbene in realtà lo faccia 
ad un livello più alto rispetto a quello corretto. Infatti andare a sostituire i layer di rete 
più bassi sul simulatore è complesso rispetto al farlo su un dispositivo reale, 
e sebbene esistano dei documenti sull'implementazione dello stack in alcuni particolari dispositivi\cite{stackpdf} essi sono vecchi di oltre 3 anni e comunque non danno molte informazioni 
riguardo l'implementazione nel simulatore. 
D'altronde non è stato neanche possibile trovare un'implementazione sostitutiva dei layer 
basilari di \tos da prendere come esempio. 
Sebbene quindi il codice sia algoritmicamente corretto e funzionante,
ci sono dei dettagli che non sono stati considerati, ad esempio il CRC, ed esso risulta 
subottimale per l'ovvia sovrapposizione delle due logiche. 

Il modulo fa uso di due timer, del componente \texttt{GenericComm}  che implementa le 
primitive di invio di messaggi, ed ovviamante del componente \tree. 
Si noti che \texttt{GeneriComm} viene usato anche dal componente \tree, ma le due istanze sono completamente indipendenti.  

I due timer potrebbero in realtà essere sostituiti da uno solo poiché si avviano strettamente
in ordine, ma sono stati separati per ottenere una maggiore chiarezza del codice.
Il ruolo del primo, \texttt{TreeTimer} è di controllare la durata del periodo necessario per
acquisire i dati sulla topologia dei nodi, al termine del quale il componente \tree, avviato 
nel momento in cui viene avviato il codice principale, viene fermato.
Ovviamente la durata di questo periodo dovrebbe essere tarata basandosi sulla topologia fisica 
dei dispositivi, sul loro numero e sulla reale frequenza di errore, ed è possibile farlo 
tramite una definizione nel file \texttt{DMac.h}.
Il codice associato all'evento \texttt{TreeTimer.fired()} si occupa anche di memorizzare 
i dati topologici e di avviare il loop principale preparando il timer principale. 
Ogni volta che il timer principale scatta si effettua una transizione di stato e viene 
impostato un nuovo tempo di attesa prima che il timer segnali di nuovo l'evento. 
Il tempo di attesa è dipendente dallo stato del nodo, che è dato dall'unione di una variabile 
enumerata, \texttt{myState} e di un valore booleano, \texttt{moreToSend}. 
In teoria sarebbe stato possibile unire le due cose ottenendo un automa a stati finiti a 
5 stati, ma in assenza di vantaggi significativi si sarebbe aggiunta una complessità maggiore 
del codice. 

Come già detto in precedenza la correttezza del tutto è strettamente dipendente dalla sincronia 
nel funzionamento di tutti i mote. Piuttosto che implementare un intero sottosistema 
di sincronizzazione si è scelto di aggirare il problema supponendo che i nodi si fossero già 
sincronizzati,dato che  tramite il simulatore possibile avviarli tutti contemporaneamente,
 o meglio in un intervallo di tempo abbastanza piccolo da essere trascurabile. 

\subsection{La coda di invio e \texttt{MIG}}
I messaggi ricevuti vengono mantenuti in una struttura del tipo implementato in
 \texttt{MyQueue.h},
basata su una coppia di strutture e su un meccanismo molto semplice di lista collegata. 
In teoria TinyOS non fornisce una primitiva per la funzione \texttt{malloc()} usata in questo 
file, ne' garantisce una gestione corretta dell'heap, ma si limita a inoltrare la richiesta 
alla libreria sottostante.  Nel nostro caso però sappiamo che il sistema operativo sottostante 
(Unix-like o win32) offre questo meccanismo per cui se ne può fare uso tranquillamente. 
E' mia convinzione che dato che la gestione della memoria dinamica è demandata solamente a 
questo singolo pezzo dell'applicazione non dovrebbero esserci problemi neanche con un porting 
diretto, ma in alternativa è possibile sostituire facilmente il codice con uno che utilizzi un 
array statico, in quanto l'implementazione della coda è completamente opaca rispetto al 
resto del codice. 
L'uso esplicito di una coda per i messaggi in questo componente porta con se anche un 
vantaggio importante in termini di semplicità di testing dell'applicazione, che a prima vista 
potrebbe non essere evidente, collegati al funzionamento del protocollo. 

Va premesso che per permettere l'interazione con i mote \tos viene fornito con una suite di 
strumenti tra cui due mirati specificamente all'invio o ricezione di dati di test al simulatore. 
Il primo di essi, \texttt{SerialForwarder}, è un'applicazione Java che si limita a fare da ponte 
tra il canale di comunicazione (reale o virtuale) e generiche applicazioni nel computer, mentre 
il secondo, \texttt{MIG} è uno strumento da riga di comando che dovrebbe teoricamente 
permettere di trasformare la definizione della \texttt{struct} che rappresenta il pacchetto, 
(necessaria per l'uso di \texttt{SendMsg} e \texttt{ReceiveMsg}), in un file \texttt{Java}, 
permettendo poi l'invio di messaggi unendo questa classe con le  funzionalità del package 
\texttt{net.tinyos} o tramite l'interprete python integrato in \tv. 
Nel caso del componente \texttt{DMac} la struttura che rappresenta il pacchetto è composta da un campo di tipo \texttt{enum pkt\_type} che rappresenta il fatto che un pacchetto sia di 
tipo \req o \ack, di un campo \texttt{bool} 
per la flag \texttt{more-to-send} e di due campi da due byte ciascuno che indicano 
mittente e dati.

Purtroppo, \texttt{MIG} sembra non essere in grado di produrre del codice appropriato per questo tipo di pacchetto, producendo valori senza significato per praticamente qualsiasi 
campo della struttura, il che ha richiesto la scrittura da zero di una classe appropriata. 
 

Il vero problema è però di natura molto più banale: affinché l'algoritmo funzioni correttamente 
i nodi devono scartare un pacchetto ricevuto nello stato di inattività e quindi diventa scomodo
cercare di cogliere al volo il breve periodo di ricezione. 
Usando la coda di messaggi è invece molto semplice far si che dopo un certo periodo di tempo 
i dati vengano introdotti in essa facendo si che il nodo si trovi nella condizione di dover 
inoltrare i dati nel prossimo slot di invio, permettendo una simulazione molto più agevole. 


\subsection{L'inoltro delle richieste}
All'entrata nello stato di invio viene richiamato il task appropriato, 
\texttt{forwardReq()}, il cui significato è ovvio.
Questo task si occupa di inoltrare il messaggio usando la primitiva di invio 
\texttt{SendMsg.send()},
ma \emph{non} estrae l'elemento in cima alla coda in quanto questo comando si limita 
ad inserire il messaggio  nella coda di invio, come già spiegato. 
Tra l'altro sembrerebbe che in realtà questa coda di invio sia limitata ad un singolo slot, 
in quanto dalle simulazioni sembra che sia impossibile ottenere il successo del comando 
\texttt{send()} se non è stato ancora segnalato \texttt{sendDone()} per il pacchetto accodato
in precedenza. 


D'altronde anche se il messaggio fosse inviato correttamente causando la segnalazione di 
\texttt{sendDone()} con un valore \texttt{SUCCESS}  
non ci sarebbero garanzie sulla ricezione da parte del prossimo nodo. 
Dunque per eliminare un messaggio dalla coda aspettiamo di ricevere 
un pacchetto di \ack, sapendo che esso sarà per forza relativo all'ultimo nostro pacchetto 
inviato, giacché sappiamo che ne viene inviato solamente uno per ogni slot. 

Nel caso dunque non venga ricevuto un \ack il pacchetto rimane nella coda di invio in attesa 
del prossimo slot libero. \`E certamente possibile che un nodo riceva un pacchetto di tipo \req 
ma il relativo pacchetto di \ack vada perso, il che introdurrebbe dei duplicati nel ciclo, 
ma questo è un problema che è semplice affrontare aggiungendo dei numeri sequenziali ad un 
livello più alto dello stack di comunicazione. 

Va notato che per questa implementazione i nodi al livello $n$ inviano sempre i propri 
pacchetti al nodo padre nell'albero tracciato inizialmente. 
Per rendere questo MAC del tutto generico rispetto all'implementazione di meccanismi di 
routing sovrastanti sarebbe sufficiente cambiare \texttt{forwardReq()} in modo che essa 
non faccia riferimento alla variabile  \texttt{nextNode} ma ad un generico comando 
\texttt{route()} che scelga il nodo seguente secondo un meccanismo qualsiasi.  

\subsection{Invio e ricezione di \ack}
La funzione \texttt{sendAck()} si occupa di impostare valori appropriati nel pacchetto di \ack 
e di inviare il pacchetto tramite le primitive di \texttt{SendMsg}. 

Il destinatario del pacchetto \ack viene individuato tramite la variabile 
globale \texttt{lastSender}, poiché i task non accettano argomenti in input ne' 
restituiscono valori. 
A prima vista potrebbe sembrare che questo meccanismo introduca una race condition nel 
caso l'evento \texttt{ReceiveMsg.receive()} venga segnalato più volte prima dell'avvio 
di \texttt{sendAck()},
ma in realtà non è così. L'evento \texttt{sendDone()} non è un evento hardware, e quindi non 
è dichiarato come \emph{asincrono} (teoricamente qualsiasi evento può essere dichiarato come 
asincrono, ma ciò andrebbe evitato)
 il che significa che esso non interromperà mai l'esecuzione di un altro evento o task. 

I task vengono eseguiti in rigido ordine FIFO, il che significa che un task $B$ posto nella coda
di scheduling da un task $A$ verrà eseguito sempre dopo di esso a meno di interruzioni asincrone.
Ciò fa si che la variabile \texttt{lastSender} funzioni implicitamente come una coda senza 
bisogno di meccanismi più complessi e dispendiosi. 

La funzione \texttt{gotAck()} è semplicissima, limitandosi ad eliminare il primo elemento 
nella coda, quando esiste la certezza che questo è stato ricevuto. 

\subsection{Il problema dei pacchetti multipli}
Secondo il documento originale un nodo dovrebbe intensificare il proprio duty cycle in due casi
\begin{itemize}
\item{se esso riceve un messaggio che indichi l'intenzione del nodo precedente di inviare altri 
pacchetti}
\item{se essendo lui intenzionato a inviare altri pacchetti esso riceve un \ack che indica che il nodo seguente è pronto ad intensificare il proprio duty cycle}
\end{itemize}
\`la seconda condizione è necessaria affinché un nodo non cominci ad intensificare il proprio 
ritmo di funzionamento senza che il nodo seguente l'abbia fatto, sprecando cicli di attività e 
quindi batteria. Ogni nodo però che si trovi lungo l'hop path è però forzato dalla prima 
condizione a farlo nel momento in cui riceve un messaggio con la flag \texttt{more-to-send} 
attiva, il che significa che l'unico nodo che deve prendere in considerazione la seconda 
condizione è il nodo che effettua la rilevazione dei dati e che si appresta ad inoltrarli. 
In questa implentazione però la seconda regola non è stata presa in considerazione, in quanto 
essa avrebbe richiesto l'utilizzo di una ulteriore serie di componenti e strumenti dedicati alla 
raccolta di dati sia a livello di codice che di simulazione.

L'aggiunta della logica per controllare la seconda condizione sarebbe d'altronde molto 
semplice, ed il codice è strutturato in modo da renderlo possibile.
Si tratterebbe, sostanzialmente, di aggiungere alla funzione \texttt{gotAck()} un controllo sul 
fatto che si stia attendendo l'arrivo di un \ack per la propria richiesta di aumentare il ritmo,
possibile tramite una variabile globale o tramite un comando apposito delegato al componente di 
raccolta dei dati.  

Un problema che non è trattato chiaramente nel paper originale\cite{DMAC} è quello di come 
riallineare il funzionamento dei mote dopo un burst di pacchetti. 
Infatti un nodo che si trovasse su differenti percorsi verso il \sink dopo un intensificazione 
del duty cycle si troverebbe ancora sincronizzato con i nodi su quel percorso, ma sarebbe 
fuori sincronia rispetto agli altri path. 
Non è stato possibile ricevere chiarimenti a riguardo dagli autori originali, e quindi è stata 
adottata una soluzione che sembrerebbe essere sufficiente: quando un nodo esce dal ritmo 
intensificato esso si riallinea ai tempi originali entrando in uno stato di inattività di 
lunghezza variabile.
 

\section{La simulazione}

\tos non possiede un'interfaccia grafica, ma si limita a fornire delle funzionalità in stile 
\texttt{printf} per mettere a schermo delle stringhe di debug. 
Ogni stringa di debug è associata ad una categoria appropriata (SIM, RADIO, LED etc\ldots), 
ed il simulatore fa uso della variabile d'ambiente \texttt{DBG} per decidere quale mostrare. 

Per rendere più semplice la simulazione esiste \tv, che non solo permette di avere una 
rappresentazione grafica, ma tramite l'interprete python integrato nell'ultima versione 
permette anche di scrivere semplici script per automatizzare l'accensione/spegnimento dei nodi,
le variazioni nelle percentuali di perdita, l'immissione di pacchetti e molto altro. 
\begin{figure}
\includegraphics{img/tinyviz}
\caption{\emph{\tv durante una simulazione, si notano i pacchetti \ack e \req}}
\end{figure}
Anche senza usare script in python è possibile automatizzare le simulazioni utilizzando un file 
di autorun.
Nell'utilizzo di \tv purtroppo sono stati incontrati molti problemi:
\begin{itemize}
\item{I documenti che indicano come utilizzare l'interprete interattivo sono obsoleti e 
praticamente tutte le gerarchie dei moduli sono differenti.}
\item{Per poter impostare dei valori di debug nel file di autorun è necessario  
cambiare il codice sorgente di \tv altrimenti la simulazione nell'ambiente \emph{cygwin} 
fallirà sempre per l'erroneo uso di \texttt{Runtime.exec}. Abbiamo inviato una patch 
agli autori per risolvere questo problema.}
\item{Tra i plugin  che abbiamo utilizzato c'è \texttt{DirectedGraph}, un plugin che fa uso 
di stringhe di debug formattate secondo una particolare sintassi per rappresentare informazioni 
grafiche. Questo plugin \emph{non può funzionare} out of the box in quanto invece di esserci 
un'assegnazione ad una variabile globale si trova una ridichiarazione, il che fa si che 
ogni accesso alla variabile globale generi un'eccezione, anche in questo caso abbiamo inviato una patch}
\item{La classe che si occupa di analizzare il file di autorun non è stata aggiornata insieme 
al resto del codice, il che fa si che sia possibile impostare da riga di comando alcuni 
argomenti mentre è impossibile farlo con il file di configurazione; 
in particolare si fa riferimento al seed per le funzioni di generazione di numeri pseudocasuali, 
fondamentale per la ripetibilità delle simulazioni.}
\item{Infine, sembra che \tv cambi sempre leggermente la definizione della topologia in qualche modo opaco, senza offrire all'utente certezza nel ripetersi delle simulazioni}
\end{itemize}

Per tutti questi motivi si è preferito generalmente usare il simulatore in modalità testuale, 
il che permette oltretutto di effettuare dei test automatizzati semplicemente salvandone
 l'output e confrontandolo con quello di una precedente simulazione. 

Un'altra problematica è quella derivante dal fatto che \tos utilizza solamente un singolo 
codice su tutti i nodi simulati, quindi non è possibile programmare diversamente il \sink, 
le foglie ed i nodi intermedi. 
La soluzione adottata è basta sul fatto che \tos assegna a tutti i nodi avviati un numero 
progressivo a partire da $0$. 
Il codice presenta quindi numerosi punti in cui il flusso di controllo 
è dipendente dal valore della macro \texttt{TOS\_LOCAL\_ADDRESS}, il che rende un po' meno 
chiara la comprensione del codice ma offre un risultato funzionante. 

Infine, come già detto, è possibile compilare il codice facendo si che esso avvii una 
simulazione automatica dell'invio dei pacchetti definendo un valore appropriato per 
\texttt{MAGIC\_SOURCE} in \texttt{DMac.h}, dalla quale dipende la definizione di un ulteriore 
deviazione nel flusso di controllo basata sull'equivalenza dell'indirizzo locale con quello di 
questa costante. 
Per le prove effettuate senza che la sorgente magica sia definita è possibile usare lo 
la classe Java \texttt{DataMsg}.

Per l'uso con \tv sono state aggiunte delle informazioni di debug mirate all'interazione con 
il plugin  \texttt{DirectedGraph}, e sebbene i risultati non siano sempre identici per i 
motivi già esposti è possibile vedere unaa semplice rappresentazione grafica dell'algoritmo 
in azione che è comunque utile a verificare il funzionamento cona una veloce occhiata. 

\chapter{Conclusioni}
Le simulazioni effettuate con i nodi disposti in griglie $5x5$, $7x7$ e $10x10$ mostrano il
comportamento atteso, sebbene esse subiscano dei lievi peggioramenti con il diminuire della 
lunghezza degli slot, facendo aumentare le collisioni.
L'impressione è che tale peggioramento sia dovuto all'implementazione del simulatore 
che impiega un certo tempo per segnalare i numerosi eventi in reti complesse.

L'abbassamento dell'intervallo di inattività porta ad un aumento del throughput 
a scapito dell'efficienza energetica, e la scelta di una durata di $18\mu$ per questo periodo 
è stata dettata dalle informazioni presenti in \cite{DMAC} riguardo i test nell'ambiente 
NS2, mentre non sembra esserci una motivazione a priori. \`E probabile che questo valore 
possa essere tranquillamente sistemato ad hoc per ogni rete in modo da raggiungere compromessi 
differenti con il risparmio energetico. 


Le simulazioni sono state effettuate usando differenti valori per le probabilità di perdita 
dei pacchetti i mostrano che la percentuale di pacchetti persi è collegata  
alla probabilità di perdita specificata a priori, il che fa pensare che i problemi relativi alla contesa del canale siano minimizzati come ci si aspetta. D'altronde nei casi in cui non avvengono
perdite di dati i dati arrivano al \sink nei tempi attesi (ovvero $n\mu$).  


Il prossimo passo nello studio di questo protocollo sarebbe quello di effettuare il 
porting dell'algoritmo al livello corretto dello stack, e di effettuare nuovi test in questo 
ambito, per poi verificare su hardware reale la validità del meccanismo, avendo così anche la 
possibilità di effettuare confronti con altri protocolli. 
La piattaforma TinyOS è però nel cuore di una cambiamento radicale\cite{tos2}, il quale 
si propone di risolvere molti dei problemi riscontrati in questa tesi, sia dal punto di vista 
del funzionamento che dal punto di vista dello sviluppo; sembrerebbe dunque opportuno 
iniziare a lavorare direttamente su \emph{TinyOS2} con le nuove versioni di simulatore, 
compilatore e librerie. 
%\begin{comment}
\appendix
%\begin{lstlisting}
\lstset{
%  stringspaces=false,
  basicstyle=\small,
%  language=C,
%  basicstyle=\ttfamily,
  numbers=left, 
  stepnumber=5, 
  numbersep=8pt,
%  frame=single,
%  numberblanklines=false,
  frame=L,
%  xleftmargin=10pt,
%  xrightmargin=20pt
  }
%\addcontentsline{toc}{chapter}{Codice del componente DMac}
\chapter{Codice del componente DMac}
%\section{DMac.h}
%\lstinputlisting{DMac.h}
\section{DMac.nc}
\lstinputlisting{DMac.nc}
\section{DMacM.nc}
\lstinputlisting{DMac.nc}
%\end{comment}
%%\chapter{Codice del componente Tree}
%\section{TreeData.nc}
%\lstinputlisting{lib/TreeData.nc}
%\section{Tree.h}
%\lstinputlisting{lib/Tree.h}
%\section{Tree.nc}
%\lstinputlisting{lib/Tree.nc}
%\section{TreeM.nc}
%\lstinputlisting{lib/TreeM.nc}

%\end{lstlisting}

\backmatter
\chapter{Ringraziamenti}
Ringrazio il Prof. Andrea Vitaletti per avermi dato la possibilità di imparare qualcosa di nuovo 
ed interessante con questa tesi, ed il mio collega Antonio Trapani per aver sbattuto la testa 
insieme a me su quel qualcosa. 
Un grazie a mio padre ed a mia madre che hanno sempre avuto fiducia in me (tranne una 
volta in cui sospetto volessero mandarmi al cepu). Uno ad Elena, che in verità non è che mi 
abbia sopportato molto, ma almeno è riuscita a distrarmi quando serviva. 
Uno agli amici per le bevute, le mangiate, le sigarette, le chiacchierate e per tutte le 
cose che hanno fatto per me, che sono davvero tante. Un grazie alle signore della segreteria 
didattica, che mi hanno fatto recuperare 5 crediti smarriti. Uno al Prof. Troya, perché mi ha
dato 23 a fisica. Ed infine, grazie alle persone che non mi ricordo più, che non si sa mai. 


\begin{thebibliography}{99}
\bibitem{DMAC} \emph{"An Adaptive Energy-Efficient and Low-Latency MAC for Data Gathering in Sensor Networks"}, G Lu, B Krishnamachari, C Raghavendra, Workshop on Energy-Efficient Wireless Communications, 2004 
\bibitem{TOSSIM}\emph{"TOSSIM: Accurate and Scalable Simulation of Entire TinyOS Applications"}, Philip Levis, Nelson Lee, Matt Welsh, and David Culler. In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys 2003).  
\bibitem{SMAC}\emph{"Medium Access Control with Coordinated, Adaptive Sleeping for Wire-less Sensor Networks"}, W. Ye, J. Heidemann, and D. Estrin, IEEE/ACM TRANSACTIONS ON NETWORKING, VOL. 12, NO. 3, giugno 2004

\bibitem{nesc}\emph{"The nesC Language: A Holistic Approach to Networked Embedded Systems"}, David Gay, Phil Levis, Rob von Behren, Matt Welsh, Eric Brewer, and David Culler. Proceedings of Programming Language Design and Implementation (PLDI) 2003, 2003.
\bibitem{tython}\emph{"Tython: A Dynamic Simulation Environment for Sensor Networks"}, Michael Demmer and Phil Levis, Network Embedded Systems Technology Winter 2004 Retreat, 2004
\bibitem{stackpdf}\emph{"Mica High Speed Radio Stack"}, Nelson Lee, Philip Nelson, Jason Hill, http://webs.cs.berkeley.edu/tos/dist-1.1.0/snapshot-1.1.0/doc/stack.pdf
\bibitem{tinyos}\emph{"TinyOS: An operating system for wireless sensor networks"}, Philip Levis, Sam Madden, Joseph Polastre, Robert Szewczyk, Kamin Whitehouse, Alec Woo, David Gay, Jason Hill, Matt Welsh, Eric Brewer, and David Culler, in Ambient Intelligence, Springer-Verlag, New York, NY, 2004.
\bibitem{sync}\emph{"Asynchronous Wakeup For Ad Hoc Networks"}, Rong Zheng, Jennifer C. Hou and Lui Sha,  in ACM MobiHoc 2003
\bibitem{tos2} \emph{"T2: A Second Generation OS For Embedded Sensor Networks"}, Philip Levis, David Gay, Vlado Handziski, Jan-Hinrich Hauer, Ben Greenstein, Martin Turon, Jonathan Hui, Kevin Klues, Cory Sharp, Robert Szewczyk, Joe Polastre, Philip Buonadonna, Lama Nachman, Gilman Tolle, David Culler, and Adam Wolisz, unpubliched. 


\end{thebibliography}
\end{document}

