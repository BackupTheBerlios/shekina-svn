% vim: encoding=utf-8
% vim: fileencoding=utf-8
\documentclass[twoside,11pt,a4paper,italian,openany]{book}
\usepackage[italian]{babel}
%è safe metterlo a 1.6, con 13 pagine arrivo a 16
\linespread{1.6}
%\renewcommand{\baselinestretch}{1.6}
\usepackage[utf8]{inputenc}
\usepackage{newcent}
\usepackage{fancyhdr}
\usepackage{listings}


\begin{document}
\frontmatter
%\maketitle
\newlength{\centeroffset}
\setlength{\centeroffset}{-0.5\oddsidemargin}
\addtolength{\centeroffset}{0.5\evensidemargin}
\thispagestyle{empty}
%\vspace*{\stretch{1}}
\noindent\hspace*{\centeroffset}\makebox[0pt][l]{\begin{minipage}{\textwidth}
\flushright
{\fontfamily{helvet}
  {\Huge\bfseries Implementazione di un MAC energy-efficient per reti di sensori wireless}
  \noindent\rule[-1ex]{\textwidth}{5pt}\\[2.5ex]
  \flushright
  {\bfseries\Large Gabriele Renzi\\[1.5ex]
  Anno Accademico 2004/2005}
}
\end{minipage}}


\pagestyle{fancy}

\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\fancyhf{} % rimuove l’attuale contenuto dell’intestazione
             % e del pi\‘e di pagina
\fancyhead[LE,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\fancyhead[RE]{\bfseries\leftmark}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{0.5pt} % riserva spazio per la linea
\fancypagestyle{plain}{%
    \fancyhead{} % ignora, nello stile plain, le intestazioni
    \renewcommand{\headrulewidth}{0pt} % e la linea
}
\newcommand{\sink}[0]{\emph{Sink}}
\newcommand{\ack}[0]{\texttt{ACK}}

\newcommand{\req}[0]{\texttt{REQ}}
\mainmatter

\chapter{Introduzione}
L'intento della tesi è l'implementazione di un protocollo MAC appositamente progettato per 
rispettare i vincoli imposti da una particolare tipologia di reti wireless, le reti di sensori.
Una Wireless Sensor Network (WSN) è composta da un gran numero di dispositivi molto semplici, 
con limitate risorse computazionali e dotati di strumentazione per rilevare eventi (movimento,
temperatura, video etc), per effettuare semplici elaborazioni e di eventuali meccanismi per 
inteagire con l'ambiente e per comunicare via radio. 
Un sensore infatti non ha le risorse sufficienti a fornire un'elaborazione complessa delle 
informazioni, e quindi una WSN viene organizzata come un albero nel quale i nodi e le foglie 
raccolgono i dati e li inoltrano verso la radice dell'albero, verso un nodo denominato 
\sink, il quale sarà  connesso ad un elaboratore in grado di gestire le informazioni 
raccolte in modo utile.
Il protocollo implementato per questa tesi, DMAC\cite{DMAC}, è appositamente pensato per una 
topologia di questo genere, e cerca di sfruttare delle euristiche per limitare sia la 
possibilità di errore nella trasmissione, sia il consumo energetico, garantendo comunque una 
bassa latenza.
Per l'implementazione del protocollo è stata utilizzata la piattaforma TinyOS, un ambiente per 
o sviluppo di applicazioni per dispositivi embedded che comprende un semplice sistema operativo
, un linguaggio di programmazione, e vari strumenti come simulatore, visualizzatori grafici, 
ambienti di scripting e molto altro. 
%\subsection{Obiettivi  della tesi}

\tableofcontents
\chapter{Il protocollo DMAC}
\section{I problemi delle reti di sensori}
In una topologia come quella appena descritta, è evidente che la parte più rilevante del 
traffico è costituita dal flusso di pacchetti verso il \sink, mentre le informazioni 
trasmesse nel verso opposto sono limitate a rari pacchetti di controllo.

I punti principali presi in considerazione dagli autori di DMAC sono:

\begin{itemize}

\item \emph{latenza}, in alcune situazione, ad esempio la rilevazione in ambito medicale o 
la videosorveglianza, è importante che le informazioni si propaghino velocemente dal nodo che le 
rileva fino al Sink
\item \emph{throughput}, applicazioni differenti [[]]possono avere necessità  di approcci differenti\ldots

\item \emph{energia}, i sensori sono dispositivi a batterie, ed in configurazioni in cui il 
numero di questi dispositivi è molto alto non è fattibile la sostituzione/ricarica ad 
intervalli freguenti

\end{itemize}

Il punto principale da cui parte l'analisi del DMAC è l'energia, in quanto si tratta di un 
vincolo particolarmente importante. DMAC, come già altri protocolli \cite{SMAC} \cite{TMAC} 
progettati in precedenza, parte dalla considerazione che il traffico in una WSN è molto leggero 
per la maggior parte del tempo, e che quindi è 
possibile ed auspicabile che i nodi non coinvolti nel trasporto di dati rimangano spenti 
quanto più possibile, in modo da risparmiare energia. 
Questo approccio è in contrasto però con l'intento di massimizzare latenza e throughput, 
perché ogni nodo che si trovi a più di un hop dal \sink dovrà attendere che il nodo successivo 
nel suo percorso entri in uno stato attivo. Questo approccio non sembra quindi essere in grado 
di scalare a reti con molti nodi. 
Un alternativa è quella di mettere in nodi uno stato di \emph{power saving} la 
maggior parte del tempo e di portarli in uno stato attivo quando ricevono una richiesta di 
comunicazione, ma lo spreco di energia in questo approccio è comunque molto maggiore di quello 
relativo ad uno stato di spegnimento effettivo. 

\section{Staggered wakeup nel DMAC}
Per massimizzare il risparmio di energia senza peggiorare troppo la latenza, 
il protocollo DMAC utilizza un meccanismo di scheduling a tre stati per i nodi, 
con l'aggiunta di un meccanismo di \emph{staggered wakeup} per cui i nodi che si trovano ad un 
hopcount maggiore dal \sink entrano nel ciclo di scheduling prima di quelli più vicini, un 
approccio che avrebbe numerosi vantaggi.

 Anzitutto il tempo di attesa per il forwarding di un
pacchetto è molto limitato, perché quando un nodo si trova in una fase attiva il mote seguente
nel suo hop path verso il \sink sarà anch'esso attivo, mentre un pacchetto che si trova a parecchi hop di distanza sarà spento. 
Con il procedere del pacchetto lungo l'hop path i nodi ancora da percorrere entrano uno alla 
volta in uno stato di attività, mentre quelli che hanno già trasmesso possono entrare in uno 
stato di inattività.
\`E facile notare che questo approccio è implicitamente scalabile, in quanto all'aumentare della profondità dell'albero non c'è un aumento dell'overhead, ne' un peggioramento dal punto di vista energetico, in quanto un nodo che si trovi distante dall'azione resterà spento finché il 
pacchetto non gli sia vicino.
Allo stesso tempo, il fatto che il pacchetto si propaghi in modo "lineare" permette di far si 
che tutti i nodi nel percorso verso il Sink siano in grado di correggere tempestivamente il loro 
scheduling se necessario, mentre i nodi non coinvolti nella trasmissione possono mantenere il 
loro ciclo di attivazione/spegnimento originario. 
Va notato che questo meccanismo ha senso solamente in una certa classe di configurazioni 
delle WSN, ovvero quando i nodi sono in un \emph{data gathering tree}, il che significa che il 
flusso dei dati va principalmente dalle foglie al \sink (i dati vengono raccolti ed inviati per essere analizzati) con rari pacchetti di controllo inviati in senso opposto. 

\section{Stati nel DMAC}
Un problema che rimane è quello relativo alla contesa del canale, anche se ovviamente il fatto 
che livelli differenti si attivino in momenti differenti riduce le dimensioni del problema.
Per far si che il messaggio arrivi correttamente e che le interferenze tra i differenti livelli 
dell'albero siano minimizzate, ogni \emph{mote} può essere in tre differenti stati, 
suddividendo il  
periodo di funzionamento attivo in una coppia di periodi,rispettivamente di ricezione e di invio.

Nello stato di ricezione un nodo attende di ricevere un pacchetto, ed in caso questo accada 
esso ne manda uno di ACK al mittente. Il nodo ricevente \emph{non inoltra} i dati in questa 
fase ma li immagazzina in una coda fino a che non si trovi nel suo stato di invio. 
Ovviamente un nodo nello stato di invio non fa altro che inoltrare un pacchetto ed attendere il relativo \texttt{ACK}.  

Gli stati si susseguono nell'ordine \emph{recv->send->sleep}, il che implica
che un nodo ad $n$ hop dal sink si troverà in uno stato di invio quando il nodo ad $n-1$ 
hop si trova in stato di ricezione. 
Nel caso che l'\texttt{ACK}  non venga ricevuto il pacchetto rimane nella coda e, o
arrivi danneggiato esso rimane nella coda di invio per essere 
inviato nel prossimo slot di invio. 
Apportune regole di drop possono essere introdotte in questo schema, ad esempio è possibile 
abbandonare il tentativo di invio dopo che per un certo numero di volte si è inoltrato un pacchetto senza ricevere il relativo \ack
 
Nel periodo di inattività i nodi spengono completamente la radio, e quindi sono isolati dalle 
trasmissioni, ma l'organizzazione temporale fa si che essi non stiano aumentando la latenza ne abbattendo il throughput, visto che i nodi vicini con i quali potrebbero comunicare sono anch'essi in uno stato di analogo. 

I periodi di invio e ricezione hanno una stessa durata $\mu$ che deve essere lunga abbastanza 
affinché un pacchetto possa essere inviato, e  sia possibile per il mittente ricevere un  
 \ack, il che è ovviamente dipendente dalla tipologia di dispositivi. 
 
Dunque ad ogni tempo $t$ teoricamente saranno solamente i nodi ad un certo livello a 
trasmettere, limitando la contesa per il canale. 

Il periodo di inattività ha una durata nettamente maggiore del periodo attivo (circa $18\mu$ in questa implementazione e nel prototipo originale discusso in \cite{DMAC}) a meno di 
\emph{burst} di pacchetti, come vedremo in seguito.
Un meccanismo di questo tipo ha bisogno evidentemente di una sincronizzazione molto precisa, ma 
esistono algoritmi validi che permettono di portare l'errore di sincronizzazione ad un millesimo 
del tempo $\mu$, quindi questo non rappresenta un problema. 

\section{Adattatività del DMAC}
Nella maggior parte delle WSN è probabile che un nodo che raccolga informazioni attraversi dei
periodi di \emph{burst} in cui esso ha parecchie informazioni da inoltrare, e si può notare che 
con il meccanismo appena descritto un'informazione che abbia bisopgno di due pacchetti avrebbe 
bisogno di almen 20 slot di tempo piuttosto che di 2 (il caso in cui i nodi fossero 
costantemente attivi), il che significa aumentare notevolmente la latenza della rete. 
Il protocollo prevede quindi dei meccanismi di autoregolazione del duty cycle basati su una flag 
\texttt{more-to-send} presente nell'header dei pacchetti.

Se un nodo ha diversi pacchetti da spedire oppure se ha ricevuto un pacchetto con questa flag
già impostata, esso la imposterà a sua volta nei pacchetti in uscita in modo in modo da 
indicare al nodo seguente che ci sono altri dati in arrivo, e che esso dovrà prepararsi a 
riceverli. Il meccanismo è chiaramente ricorsivo e fa si che l'informazione si propaghi fino 
al \sink sulla base di sincronizzazioni locali, il che significa che nel caso un pacchetto dal 
nodo $X$ al nodo $Y$ vada perso o sia danneggiato nesuno dei nodiche si trovano sull'hop path da 
$Y$ al \sink verrà informato della necessità di cambiare il proprio duty cycle, ed essi quindi 
non sprecheranno risorse inutilmente rimanendo attivi in un periodo in cui non potrebbero 
comunque ricevere altri dati. 


Va sottolineato che nel DMAC, quando un nodo riceve un pacchetto \texttt{more-to-send} esso non 
rimane in uno degli stati attivi nello slot immediatamente seguente, bensi esso entra in uno stato di inattività ma riducendone la durata a  
$3\mu$ per poi tornare nello stato di ricezione. Questa attesa è necessaria affinché il 
pacchetto abbia il tempo di propagarsi tra i nodi seguenti, senza che ci siano collisioni con i
pacchetti dei livelli precedenti. 
% pippa sul fatto che potebber essre sprecato un periodo
% pippa sul data prediction


\chapter{La piattaforma TinyOS}

\section{Un sistema operativo per WS}
Lo sviluppo della tecnologia dei sensori wireless pùò essere paragonato a quella delle 
piattaforme PC domestiche. Ad un aumento costante della potenza di calcolo si è accompagnato un 
aumento nella gamma di periferiche (memoria non volatile, attuatori, sensori di 
luce/calore/movimento etc\ldots) ed un aumento della disponibilità di tale hardware.
Esattamente come per l'informatica domestica, sono sorte quindi la possibilità e la necessità 
di gestire i
componenti ad un livello più alto di astrazione, esattamente come per i PC si è passati 
da sistemi operativi 
ad hoc scritti in assembly a strutture stratificate in linguaggi di livello più alto. 

TinyOS rappresenta appunto un sistema operativo "\emph{moderno}" per WS, che fornisce 
utili astrazioni per la realizzazione di applicazioni, ad un tempo rendendole più 
semplici da realizzare e facilmente portabili tra diversi modelli di sensore.

Tra le funzionalità che TinyOS offre ci sono
\begin{itemize}

\item{astrazione dei driver per sensori, radio, ed ogni altra periferica  }

\item{vari meccanismi per la concorrenza }

\item{gestione della memoria e dello scheduling}

\item{un linguaggio di sviluppo (NesC) che supporti direttamente tutto questo}
\end{itemize}

TinyOS è software open source, disponibili a tutti  e con una comunità in crescita.
Esso offre inoltre alcuni strumenti a corredo interessanti, tra i quali sono presenti 
simulatori, visualizzatori, database, ed interfacce con numerosi linguaggio di programmazione. 



\section{NesC un linguaggio per dispositivi wireless embedded}

Sebbene il C sia ormai lo standard de facto come \emph{system language} esso è per molti versi 
un linguaggio vecchio, che sebbene abbia conosciuto diverse revisioni mantiene comunque una 
netta mancanza per costrutti di alto livello. 
NesC è basato sul C, sia a livello sintattico che a livello semantico. 
In effetti il compilatore NesC è effettivamente implementato come un frontend per il noto compilatore multipiattaforma GCC \cite{nesc}.

NesC estende però il C in varie direzioni ortogonali, che rispecchiano da un lato le funzionalità
di TinyOS e dall'altro le necessità dell'hardware particolare su cui esso deve 
funzionare. 

\subsection{Task}
TinyOS fornisce alcune primitive per la concorrenza che sono replicate nel design di NesC.
Ogni dispositivo può avere in esecuzione differenti \emph{task}, i quali vengono attivati 
secondo un 
meccanismo di scheduling non preemptive, quindi funzionano finché la funzione associata non 
raggiunge un \texttt{return}. Si tratta di un meccanismo di concorrenza a stato condiviso in cui 
i task possono comunicare solamente tramite variabili condivise, in modo analogo a 
\emph{pthread} o ai thread in Java/.NET, con la differenza importante che ogni programma scritto in  NesC è soggetto ad 
un'analisi globale che è teoricamente in grado di individuare possibili race condition e 
condurre l'autore alla loro eliminazione, riducendo il numero di bug. 
Questo meccanismo no è però infallibile, e può sbagliare producendo false positive 
(eliminabili indicando esplicitamente al compilatore che non ci sono race condition) o non 
individuando dei problemi[[]]. i
Ogni task mantiene il controllo della CPU fino a che non termina, senza essere mai interrotto da un altro task, e non esiste un meccanismo di sincronizazione esplicita 
dei task in stile "\emph{join}".
Un task può però essere interrotto da un evento asincrono.


\subsection{Eventi}
Lo scheduler di TinyOS può comunque sempre decidere di interrompere il funzionamento di un task 
se esso riceve un evento hardware (preempting). 
Per modellare questi casi NesC offre il meccanismo degli eventi, 
che sono speciali funzioni annotate come tali e che vengono richiamate in numerosi 
casi, l'arrivo di un segnale radio, l'avvio di un timer, l'inizio della ricezione di dati da un sensore etc...
Gli eventi non sono necessariamente asincroni, e tipicamente eventi di bassa priorità (per esempio il segnalare che un pacchetto è stato inviato) non lo sono.
\`E possibile definire propri eventi prependendo la keyword \texttt{event} ad una qualsiasi 
funzione, a differenza dei task che possono essere applicati solamente a funzioni \texttt{void}.
Poiché un evento asincrono potrebbe interrompere una funzione in un punto qualsiasi della sua esecuzione, NesC offre un meccanismo per garantire che un blocco di codice venga eseguito in 
maniera atomica,  permettendo di annotare una qualsiasi variabile come \texttt{atomic} o 
di inserire un blocco di codice indicate come tale in maniera simile a \texttt{synchronized} 
in java.


 

\subsection{Componenti ed Interfacce}
TinyOS come molti altri SO usa e fornisce delle interfacce per rappresentare gli oggetti del 
sistema (layer di rete, driver etc...). 
Mentre però in molte piattaforme classiche (Win32, Linux, BSD) ciò è fatto informalmente 
usando il linguaggio C, NesC è stato esteso per supportare sintatticamente l'idea di 
programmazione a componenti. 
Un'interfaccia dichiara di fornire un certo numero di 
\begin{itemize}

\item{eventi, il che significa che un componente che usi l'interfaccia deve fornire appropriati
handler} 

\item{comandi, cioè procedure o funzioni che verranno chiamate dal componente che usa l'interfaccia}
\end{itemize}

Un componente può implementare una o più interfacce (o implementare un'interfaccia più volte 
con nomi diversi, il che fornisce una qualche similarità con la progrmmazione ad oggetti), 
ed è composto principalmente da due parti, una di configurazione 
(dichiarazione di componenti ed interfacce usati) ed una di implementazione.
La configurazione è il cuore della parte \emph{Component-Oriented} di NesC, in quanto è 
il punto in cui viene effettuata l'associazione tra componenti ed interfacce, indicato come 
\emph{wiring}, offrendo una grande flessibilità. 
La parte di implementazione contiene riferimento solamente ai nomi inhdicati nella configurazione
, rendendo facilmente sostituibili i componenti.
L'implementazione contiene poi ovviamente il codice di comandi ed eventi, e può contenere un 
certo numero di variabili globali accessibili da tutte le funzioni del componente. 

Per massimizzare il riuso e la semplicità di programmazione componenti ed interfacce possono 
essere parametrizzati, un qualsiasi valore può essere 
incluso in fase di configurazione effettuando una sorta di \emph{currying} dell'interfaccia. 
In versioni più recenti di NesC è possibile avere anche type parameter, ma con la versione della piattaforma usata in questa tesi ciò non è stato possibile. 


%[[ ed eventuali dichiarazioni 
%riguardo i rapporti tra determinate interfacce (è possibile dichiarare che il modulo 
%\texttt{RedBlackTree} equivale all'interfaccia \texttt{Dictionary} anche se nel primo non 
%c'è nessun  riferimento alla seconda);  ]]



\subsection{Staticità}

NesC è un linguaggio completamente statico, nel senso che la maggior parte delle attività 
possibili è fatta a compile time. Con ciò non si intende solo un semplice type checking sui 
moduli compilativi, ma anche una gestione statica della memoria (in realtà è possibile usare 
\texttt{malloc()} e simili ma a patto di essere molto cauti) e con l'intero call graph disponibile a compile time. 

NesC fa uso di \emph{whole program analisys and optimization} (WPA/WPO) per raggiungere alte
performance tramite ottimizzazioni interprocedurali, constant propagation, dead code 
elimination etc (ma esse sono possibili in via teorica teoricamente, al momento molto poco 
di ciò è implementato).
Allo stesso tempo grazie alla WPA esso puo offrire garanzie riguardo l'affidabilità dei 
programmi (l'individuazione di possibili race condition sui dati condivisi è possibile proprio 
in virtù di questo fatto).


\newcommand{\tos}{\texttt{TOSSIM} }

\section{\tos, un simulatore per PC}
\tos\cite{TOSSIM} è un simulatore per personal computer  in grado di far funzionare lo 
stesso codice NesC che è stato scritto per i dispositivi embedded. 
I vantaggi di questo approccio è che il codice può essere scritto, debuggato e testato su 
una normale macchina casalinga, e poi essere trasportato senza cambiamenti su un dispositivo 
reale. 
\tos è in sostanza una libreria che viene connessa in fasi di link con il codice NesC 
tradotto in codice C, e che fornisce il \texttt{main()} ed altro, producendo un 
eseguibile nativo, per ogni applicazione TinyOS.

\tos è in grado di accettare in input un modello delle probabilità di perdita di pacchetti 
tra due nodi qualunque, o di usare dei modelli teorici predefiniti, ma non comprende ne' 
informazioni topologiche, ne' modelli di alto livello, i quali possono però essere sempre 
definiti in termini di probabilità di perdita su un qualsiasi arco.
\newcommand{\tv}{\texttt{TinyViz}}
Allo scopo di definire questi modelli, sono stati creati vari strumenti, tra i quali 
\texttt{LossyBuilder}, un programma in grado di generare file di testo rappresentanti 
la distribuzione di una rete di nodi in topologia a griglia, e \tv.
\tv è in realtà un sistema molto più complesso, basato su un architettura a plugin. 

\tos fornisce un'interfaccia modellata sui meccanismi di TinyOS, cioè comandi ed eventi, 
che gli opermette di interoperare con dispositivi esterni, permettendo così l'implementazione in componenti separati di tutta una serie di funzionalità ad esempio l'analisi dei segnali, la visualizzazione di una topologia, l'iniezione di pacchetti radio e di informazioni per i sensori etc.. 
\tv è un ambient grafico ralizzato in java che astrae i meccanismi di base di questa interazione 
con \tos esponendoli tramite un'interfaccia non molto complessa ad una serie di plugin 
caricabili a runtime.  La distribuzione di TinyOS comprende un insieme variegato di plugin che 
però sono purtroppo in molti casi non mantenuti e non funzionano. Il codice di tinyviz è 
in generale non troppo ben tenuto. 
Durante la realizzazione di questa tesi è avvenuta una riscrittura di questo ambiente che lo ha 
portato ad essere fondato su jython\cite{tython}, cioè un interprete python per JVM, 
il che permette la realizzazione di semplici script (ma anche programmi complessi).
 

\chapter{L'implementazione}
\section{Visione d'insieme}
Per realizzare l'applicazione il tutto è stato strutturato in due differenti moduli più 
una libreria C elementare per la gestione di una coda.

Il primo modulo si occupa dell'individuazione delle informazioni relative alla topologia, 
mantenendo per ogni nodo informazioni sulla sua distanza dal \sink e su quale sia il prossimo 
nodo nel suo hop path.  
Quando l'albero è stato mappato inizia il loop principale dei mote, che è una 
semplice macchina a stati finiti con tre stati implementata con degli \texttt{if/else}.
Il codice fa uso di una coda per i pacchetti da inoltrare implementata nel file [[]], realizzata tramite una semplice lista collegata. NesC nella versione utilizata non permette di parametrizzare un'interfaccia tramite tipi, il che significa che non era possibile implementare 
un'interfaccia che fosse contemporaneamente type safe e generica, quindi all'interno del codice si fa riferimento esplicito ai tipi definiti nel resto del programma. 



\newcommand{\treedata}{\texttt{TreeData}}
\newcommand{\tree}{\texttt{Tree}}

\section{Il componente \treedata}
La mappatura dell'albero è affidata ad un componente apposito \tree, che implementa l'interfaccia
\texttt{StdControl} e ne definisce una sua, \treedata.
L'interfaccia \texttt{StdControl} è un'interfaccia generica per un componente NesC, che fornisce 
comandi per attivare, inizare le operazioni e disattivare un componente.
L'attivazione di \tree porta all'attivazione del componente di rete, \texttt{GenericComm}, 
il quale fornisce implementazioni delle interfacce di basso livello per l'invio e la ricezione 
di pacchetti. 
Quando viene richiamato il comando \texttt{StdControl.start()} il modulo inizio la mappatura 
dell'albero seguendo un processo molto semplice, a partire dal \sink. 
Questo nodo invia un segnale broadcast indicando il suo indirizzo di rete ed il numero di hop 
necessari a raggiungerlo ($1$, per il \sink). Ogni nodo che riceve questo messaggio provvede poi ad inoltrarlo  sua volta, di nuovo in broadcast, aggiornando ovviamente le informazioni su mittente ed hop count. 
Quando un nodo riceve un messaggio viene segnalato l'evento 
\texttt{ReceiveMsg.receive()}, ed è li che si trova la vera logica del componente. 
Infatti il codice si occupa di impostare appropriatamente dele variabili globali 
(a livello di componente) che rappresentano l'hop count ed il prosimo node nel percorso verso 
il \sink, ma solamente nel caso che il messaggio ricevuto indichi la possibilità di raggiungerlo
in un numero di hop minore rispetto a quello registrato precedentemente. 

Il Sink, dal canto suo, continua ad inviare pacchetti ad intervalli regolari (cioè ogni volta 
che viene segnalato \texttt{SinkTimer.fired()}, in modo da evitare eventuali errori dovuti alla 
perdita di pacchetti o a problemi di trasmissione.
Il processo continua fino a che il componente non viene fermato, tramite 
\texttt{StdControl.stop()}, ed è il codice in \texttt{DmacM.nc} che si occupa di questo.

Le informazioni immagazzinate da questo componente sono accessibili tramite i due comandi 
definiti nell'interfaccia \treedata, e cioè \texttt{getNextHopToSink()} e \texttt{getNextHopToSink()}. 
Alcune note aggiuntive su questa implementazione:
\begin{itemize}
\item{L'implementazione non specifica quale nodo sia il \sink, è il codice che usa questo 
componente che può decidere quale sia il nodo che deve iniziare la mappatura dell'albero, 
tramite \texttt{StdControl.start()}, il che rende il modulo più flessibile}

\item{In realtà l'albero tracciato in questo modo non implica che un nodo al livello $n$ sia in 
grado di inviare messaggi al livello $n-1$, perché è possibile che ci siano delle asimmetrie 
nelle capacità di invio/ricezione; \tos supporta questo tipo di topologie, in quanto si 
occupa solamente di percentuali di errore tra due archi generici, e gli archi $(a,b)$ e $(b,a)$ 
vengono considerati differenti. Per questa simulazione non ci siamo occupati di questo problema,
assumendo che se la comunicazione può avvenire in un verso possa funzionare anche nell'altro. 
D'altro canto sarebbe relativamente semplice cambiare una parte dell'implementazione del modulo \tree utilizzando un algoritmo di mappatura più corretto mantenendo comunque la stessa 
interfaccia.}

\item{In questo codice, ed anche nel codice del resto del programma, si può notare la presenza 
di una variabile di tipo \texttt{TOS\_Msg} che è dichiarata globalmente.
Ciò è necessario poiché il meccanismo di invio di un pacchetto radio è organizzato in due fasi, 
la prima viene attivata tramite il comando \texttt{SendMsg.send()}, che in realtà \emph{non} invia il messaggio ma lo mette in una coda di invio.
La seconda fase viene effettuata dal layer sottostante, che una volta inviato il pacchetto 
richiama l'evento \texttt{SendMsg.sendDone()}. 
Se quindi la variabile che rappresenta il messaggio fosse dichiarata come locale in 
\texttt{SinkTimer.fired()} essa verrebbe deallocata quando la funzione terminasse,  
ed al momento dell'effettivo invio il layer sottostante si troverebbe un riferimento 
ad una zona di memoria non valida.}
\end{itemize}

Infine, va detto che l'evento \texttt{SendMsg.sendDone()} viene richiamato passandogli un argomento che  dovrebbe rappresentare se l'invio è avvenuto correttamente o meno. 
Nel simulatore questo valore non è affidabile, in quanto il valore \texttt{SUCCESS}, di ovvio significato, è cablato nel codice senza alcuna condizione. 
Purtroppo sembra che in \tos siano state prese numerose scorciatoie di questo tipo, il che 
rende lo sviluppo usando il simulatore decisamente più problematico. 


\section{Il cuore dell'applicazione}
Il componente Dmac implementa l'algoritmo descritto in \cite{DMAC} sebbene in realtà lo faccia 
a un livello più alto rispetto a quello corretto. Infatti andare a sostituire i layer di rete 
più bassi sul simulatore è particolarmente complesso rispetto al farlo su un dispositivop reale, 
oltre che assolutamente non documentato, ed in effetti non è neanche riuscito di trovare 
un'implementazione sostitutiva dei layer basilari di \tos da prendere come esempio. 
Sebbene quindi l'algoritmo funzioni correttamente, ci sono dei dettagli che non sono stati 
considerati, ad esempio il CRC.
Il modulo fra uso di due timer, del componente \texttt{GenericComm}  che implementa le 
primitive di invio di messaggi, ed ovviamante del componente \tree. 
I due timer potrebbero in realtà essere sostituiti da un uno solo, ma sonob stai separati 
per ottenwre una maggiore chiarezza del codice.
Il ruolo del primo, \texttt{TreeTimer} è di controllare la durata del periodo necessario per
acquisire i dati sulla topologia dei nodi, al termine del quale il componente \tree, avviato 
nel momento in cui viene avviato il codice principale, viene fermato.
Ovviamente la durata di questo periodo dovrebbe essere tarata basandosi sulla topologia fisica 
dei dispositivi, sul loro numero e sulla reale frequenza di errore, ed è possibile farlo 
tramite una definizione nel file \texttt{Dmac.h}.
Il codice dell'evento \texttt{TreeTimer.fired()} si occupa anche di memorizzare i dati topologici
e di avviare il loop principale preparando il timer principale. 
Ogni volta che il timer principale scatta si effettua una transizione di stato e viene 
impostato un nuovo tempo di attesa prima che il timer segnali di nuovo l'evento. 
Il tempo di attesa è dipendente dallo stato del nodo, che è dato dall'unione di una variabile 
di tipo \texttt{enum}, \texttt{myState} e di un valore booleano, \texttt{moreToSend}. 
In teoria sarebbe stato possibile unire le due cose ottenenedo un automa a stati finiti a 
5 stati, ma in assenza di vantaggi significativi si sarebbe aggiunta una complessità maggiore 
del codice. 


All'entrata nello stato di ricezione viene richiamato il task appropriato, 
\texttt{forwardReq()}, il cui significato è ovvio.
I messaggi vengono mantenuti in una coda implementata nel file \texttt{MyQueue.h}, 
basata su una coppia di strutture ed un meccanismo molto emplice di lista collegata. 
In teoria TinyOS non fornisce una primitiva per la funzione \texttt{malloc()} usata in questo 
file, ne' garantisce una gestione corretta dell'heap, ma si limita a inoltrare la richiesta 
alla libreria sottostante.  Nel nostro caso però sappiamo che il sistema operativo sottostante 
(Unix-like o win32) offre questo meccanismo per cui possimo farne uso tranquillamente. 
E' mia convinzione che dato che la gestione della memoria dinamica è demandata solamente a 
questo singolo pezzo dell'applicazione non dovrebbero esserci problemi neanche con un porting 
diretto, ma in alternativa è possibile sostituire facilmente il codice con uno che utilizzi un 
array statico. 
\texttt{forwardReq()} non effettua una "pop" dell'elemento in cima alla coda, 
in quanto non è garantito il successo del comando \texttt{SendMsg.send()}, 
ne' è garantito che il messaggio sia inviato con successo anche se questa funzione ha successo.
D'altronde anche se il messaggio fosse inviato correttamente ( cioè venisse segnalata \texttt{SendMsg.sendDone()} con un valore di \texttt{SUCCESS} )  non avremo garanzie sulla ricezione da 
parte del prossimo nodo. Dunque per eliminare un messaggio dalla coda aspettiamo di ricevere 
un pacchetto di \ack, sapendo che esso sarà per forza relativo all'ultimo nostro pacchetto 
inviato, giacché sappiamo che ne viene inviato soltanto uno per ogni slot. 

Nel caso dunque non venga ricevuto un \ack il pacchetto rimane nella coda di invio in attesa 
del prossimo slot libero. \`E certamente possibile che un nodo riceva un pacchetto di tipo \req 
ma il relativo pacchetto di \ack vada perso, il che introdurrebbe dei duplicati nel ciclo, 
ma questo è un problema che è semplice affrontare aggiungendo dei numeri sequenziali ad un 
livello più alto dello stack di comunicazione. 


La funzione \texttt{sendAck()} si occupa di impostare valori appropriati nel pacchetto di \ack 
e di inviare il pacchetto tramite il layer sottostante 


 




l'ack viene inviato basandoci sul valore della variabile globale \texttt{lastSender}, 
in quanto sarebbe impossibile far arrivare al task l'informazione in un altro modo, vista la 
natura asincrona dell'algoritmo.  
In teoria invece di una singola variabile dovrebbe esserci una lista di indirizzi, 
in quanto un nodo potrebbe ricevere differenti pacchetti in un solo slot di ricezione, il che implicherebbe la ne 




\section{La simulazione}


\appendix
%\begin{lstlisting}
\lstset{
%  stringspaces=false,
  basicstyle=\small,
%  language=C,
%  basicstyle=\ttfamily,
  numbers=left, 
  stepnumber=5, 
  numbersep=8pt,
%  frame=single,
%  numberblanklines=false,
  frame=L,
%  xleftmargin=10pt,
%  xrightmargin=20pt
  }
%\addcontentsline{toc}{chapter}{Codice del componente DMac}
\chapter{Codice del componente DMac}
\section{DMac.h}
\lstinputlisting{DMac.h}
\section{DMac.nc}
\lstinputlisting{DMac.nc}
\section{DMacM.nc}
\lstinputlisting{DMac.nc}

\chapter{Codice del componente Tree}
\section{TreeData.nc}
\lstinputlisting{lib/TreeData.nc}
\section{Tree.h}
\lstinputlisting{lib/Tree.h}
\section{Tree.nc}
\lstinputlisting{lib/Tree.nc}
\section{TreeM.nc}
\lstinputlisting{lib/TreeM.nc}

%\end{lstlisting}

\backmatter
\begin{thebibliography}{99}
\bibitem{DMAC} "An Adaptive Energy-Efficient and Low-Latency MAC for Data Gathering in Sensor Networks", \emph{G Lu, B Krishnamachari, C Raghavendra - Workshop on Energy-Efficient Wireless Communications, 2004} 
\bibitem{TOSSIM} "TOSSIM: Accurate and Scalable Simulation of Entire TinyOS Applications", \emph{Philip Levis, Nelson Lee, Matt Welsh, and David Culler. In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys 2003)}.  
\bibitem{SMAC} smac
\bibitem{TMAC} tmac
\bibitem{nesc} "The nesC Language: A Holistic Approach to Networked Embedded Systems", \emph{David Gay, Phil Levis, Rob von Behren, Matt Welsh, Eric Brewer, and David Culler. Proceedings of Programming Language Design and Implementation (PLDI) 2003, June 2003}.
\bibitem{tython} "Tython: A Dynamic Simulation Environment for Sensor Networks", \emph{Michael Demmer and Phil Levis}
\end{thebibliography}
\end{document}

