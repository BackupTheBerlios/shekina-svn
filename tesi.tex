% vim: encoding=utf-8
% vim: fileencoding=utf-8
\documentclass[twoside,11pt,a4paper,italian,openany]{book}
\usepackage[italian]{babel}
%è safe metterlo a 1.6, con 13 pagine arrivo a 16
\linespread{1.6}
%\renewcommand{\baselinestretch}{1.6}
\usepackage[utf8]{inputenc}
\usepackage{newcent}
\usepackage{fancyhdr}
\usepackage{listings}


\begin{document}
\frontmatter
%\maketitle
\newlength{\centeroffset}
\setlength{\centeroffset}{-0.5\oddsidemargin}
\addtolength{\centeroffset}{0.5\evensidemargin}
\thispagestyle{empty}
%\vspace*{\stretch{1}}
\noindent\hspace*{\centeroffset}\makebox[0pt][l]{\begin{minipage}{\textwidth}
\flushright
{\fontfamily{helvet}
  {\Huge\bfseries Implementazione di un MAC energy-efficient per reti di sensori wireless}
  \noindent\rule[-1ex]{\textwidth}{5pt}\\[2.5ex]
  \flushright
  {\bfseries\Large Gabriele Renzi\\[1.5ex]
  Anno Accademico 2004/2005}
}
\end{minipage}}


\pagestyle{fancy}

\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\fancyhf{} % rimuove l’attuale contenuto dell’intestazione
             % e del pi\‘e di pagina
\fancyhead[LE,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\fancyhead[RE]{\bfseries\leftmark}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{0.5pt} % riserva spazio per la linea
\fancypagestyle{plain}{%
    \fancyhead{} % ignora, nello stile plain, le intestazioni
    \renewcommand{\headrulewidth}{0pt} % e la linea
}
\newcommand{\sink}[0]{\emph{Sink}}
\newcommand{\ack}[0]{\texttt{ACK}}

\newcommand{\req}[0]{\texttt{REQ}}
\mainmatter

\chapter{Introduzione}
L'intento della tesi è l'implementazione di un protocollo MAC appositamente progettato per 
rispettare i vincoli imposti da una particolare tipologia di reti wireless, le reti di sensori.
Una Wireless Sensor Network (WSN) è composta da un gran numero di dispositivi molto semplici, 
con limitate risorse computazionali e dotati di strumentazione per rilevare eventi (movimento,
temperatura, video etc), per effettuare semplici elaborazioni e di eventuali meccanismi per 
inteagire con l'ambiente e per comunicare via radio. 
Un sensore infatti non ha le risorse sufficienti a fornire un'elaborazione complessa delle 
informazioni, e quindi una WSN viene organizzata come un albero nel quale i nodi e le foglie 
raccolgono i dati e li inoltrano verso la radice dell'albero, verso un nodo denominato 
\sink, il quale sarà  connesso ad un elaboratore in grado di gestire le informazioni 
raccolte in modo utile.
Il protocollo implementato per questa tesi, DMAC\cite{DMAC}, è appositamente pensato per una 
topologia di questo genere, e cerca di sfruttare delle euristiche per limitare sia la 
possibilità di errore nella trasmissione, sia il consumo energetico, garantendo comunque una 
bassa latenza.
Per l'implementazione del protocollo è stata utilizzata la piattaforma TinyOS, un ambiente per 
o sviluppo di applicazioni per dispositivi embedded che comprende un semplice sistema operativo
, un linguaggio di programmazione, e vari strumenti come simulatore, visualizzatori grafici, 
ambienti di scripting e molto altro. 
%\subsection{Obiettivi  della tesi}

\tableofcontents
\chapter{Il protocollo DMAC}
\section{I problemi delle reti di sensori}
In una topologia come quella appena descritta, è evidente che la parte più rilevante del 
traffico è costituita dal flusso di pacchetti verso il \sink, mentre le informazioni 
trasmesse nel verso opposto sono limitate a rari pacchetti di controllo.

I punti principali presi in considerazione dagli autori di DMAC sono:

\begin{itemize}

\item \emph{latenza}, in alcune situazione, ad esempio la rilevazione in ambito medicale o 
la videosorveglianza, è importante che le informazioni si propaghino velocemente dal nodo che le 
rileva fino al Sink
\item \emph{throughput}, applicazioni differenti [[]]possono avere necessità  di approcci differenti\ldots

\item \emph{energia}, i sensori sono dispositivi a batterie, ed in configurazioni in cui il 
numero di questi dispositivi è molto alto non è fattibile la sostituzione/ricarica ad 
intervalli freguenti

\end{itemize}

Il punto principale da cui parte l'analisi del DMAC è l'energia, in quanto si tratta di un 
vincolo particolarmente importante. DMAC, come già altri protocolli \cite{SMAC} \cite{TMAC} 
progettati in precedenza, parte dalla considerazione che il traffico in una WSN è molto leggero 
per la maggior parte del tempo, e che quindi è 
possibile ed auspicabile che i nodi non coinvolti nel trasporto di dati rimangano spenti 
quanto più possibile, in modo da risparmiare energia. 
Questo approccio è in contrasto però con l'intento di massimizzare latenza e throughput, 
perché ogni nodo che si trovi a più di un hop dal \sink dovrà attendere che il nodo successivo 
nel suo percorso entri in uno stato attivo. Questo approccio non sembra quindi essere in grado 
di scalare a reti con molti nodi. 
Un alternativa è quella di mettere in nodi uno stato di \emph{power saving} la 
maggior parte del tempo e di portarli in uno stato attivo quando ricevono una richiesta di 
comunicazione, ma lo spreco di energia in questo approccio è comunque molto maggiore di quello 
relativo ad uno stato di spegnimento effettivo. 

\section{Staggered wakeup nel DMAC}
Per massimizzare il risparmio di energia senza peggiorare troppo la latenza, 
il protocollo DMAC utilizza un meccanismo di scheduling a tre stati per i nodi, 
con l'aggiunta di un meccanismo di \emph{staggered wakeup} per cui i nodi che si trovano ad un 
hopcount maggiore dal \sink entrano nel ciclo di scheduling prima di quelli più vicini, un 
approccio che avrebbe numerosi vantaggi.

 Anzitutto il tempo di attesa per il forwarding di un
pacchetto è molto limitato, perché quando un nodo si trova in una fase attiva il mote seguente
nel suo hop path verso il \sink sarà anch'esso attivo, mentre un pacchetto che si trova a parecchi hop di distanza sarà spento. 
Con il procedere del pacchetto lungo l'hop path i nodi ancora da percorrere entrano uno alla 
volta in uno stato di attività, mentre quelli che hanno già trasmesso possono entrare in uno 
stato di inattività.
\`E facile notare che questo approccio è implicitamente scalabile, in quanto all'aumentare della profondità dell'albero non c'è un aumento dell'overhead, ne' un peggioramento dal punto di vista energetico, in quanto un nodo che si trovi distante dall'azione resterà spento finché il 
pacchetto non gli sia vicino.
Allo stesso tempo, il fatto che il pacchetto si propaghi in modo "lineare" permette di far si 
che tutti i nodi nel percorso verso il Sink siano in grado di correggere tempestivamente il loro 
scheduling se necessario, mentre i nodi non coinvolti nella trasmissione possono mantenere il 
loro ciclo di attivazione/spegnimento originario. 
Va notato che questo meccanismo ha senso solamente in una certa classe di configurazioni 
delle WSN, ovvero quando i nodi sono in un \emph{data gathering tree}, il che significa che il 
flusso dei dati va principalmente dalle foglie al \sink (i dati vengono raccolti ed inviati per essere analizzati) con rari pacchetti di controllo inviati in senso opposto. 

\section{Stati nel DMAC}
Un problema che rimane è quello relativo alla contesa del canale, anche se ovviamente il fatto 
che livelli differenti si attivino in momenti differenti riduce le dimensioni del problema.
Per far si che il messaggio arrivi correttamente e che le interferenze tra i differenti livelli 
dell'albero siano minimizzate, ogni \emph{mote} può essere in tre differenti stati, 
suddividendo il  
periodo di funzionamento attivo in una coppia di periodi,rispettivamente di ricezione e di invio.

Nello stato di ricezione un nodo attende di ricevere un pacchetto, ed in caso questo accada 
esso ne manda uno di ACK al mittente. Il nodo ricevente \emph{non inoltra} i dati in questa 
fase ma li immagazzina in una coda fino a che non si trovi nel suo stato di invio. 
Ovviamente un nodo nello stato di invio non fa altro che inoltrare un pacchetto ed attendere il relativo \texttt{ACK}.  

Gli stati si susseguono nell'ordine \emph{recv->send->sleep}, il che implica
che un nodo ad $n$ hop dal sink si troverà in uno stato di invio quando il nodo ad $n-1$ 
hop si trova in stato di ricezione. 
Nel caso che l'\texttt{ACK}  non venga ricevuto il pacchetto rimane nella coda e, o
arrivi danneggiato esso rimane nella coda di invio per essere 
inviato nel prossimo slot di invio. 
Apportune regole di drop possono essere introdotte in questo schema, ad esempio è possibile 
abbandonare il tentativo di invio dopo che per un certo numero di volte si è inoltrato un pacchetto senza ricevere il relativo \ack
 
Nel periodo di inattività i nodi spengono completamente la radio, e quindi sono isolati dalle 
trasmissioni, ma l'organizzazione temporale fa si che essi non stiano aumentando la latenza ne abbattendo il throughput, visto che i nodi vicini con i quali potrebbero comunicare sono anch'essi in uno stato di analogo. 

I periodi di invio e ricezione hanno una stessa durata $\mu$ che deve essere lunga abbastanza 
affinché un pacchetto possa essere inviato, e  sia possibile per il mittente ricevere un  
 \ack, il che è ovviamente dipendente dalla tipologia di dispositivi. 
 
Dunque ad ogni tempo $t$ teoricamente saranno solamente i nodi ad un certo livello a 
trasmettere, limitando la contesa per il canale. 

Il periodo di inattività ha una durata nettamente maggiore del periodo attivo (circa $18\mu$ in questa implementazione e nel prototipo originale discusso in \cite{DMAC}) a meno di 
\emph{burst} di pacchetti, come vedremo in seguito.
Un meccanismo di questo tipo ha bisogno evidentemente di una sincronizzazione molto precisa, ma 
esistono algoritmi validi che permettono di portare l'errore di sincronizzazione ad un millesimo 
del tempo $\mu$, quindi questo non rappresenta un problema. 

\section{Adattatività del DMAC}
Nella maggior parte delle WSN è probabile che un nodo che raccolga informazioni attraversi dei
periodi di \emph{burst} in cui esso ha parecchie informazioni da inoltrare, e si può notare che 
con il meccanismo appena descritto un'informazione che abbia bisopgno di due pacchetti avrebbe 
bisogno di almen 20 slot di tempo piuttosto che di 2 (il caso in cui i nodi fossero 
costantemente attivi), il che significa aumentare notevolmente la latenza della rete. 
Il protocollo prevede quindi dei meccanismi di autoregolazione del duty cycle basati su una flag 
\texttt{more-to-send} presente nell'header dei pacchetti.

Se un nodo ha diversi pacchetti da spedire oppure se ha ricevuto un pacchetto con questa flag
già impostata, esso la imposterà a sua volta nei pacchetti in uscita in modo in modo da 
indicare al nodo seguente che ci sono altri dati in arrivo, e che esso dovrà prepararsi a 
riceverli. Il meccanismo è chiaramente ricorsivo e fa si che l'informazione si propaghi fino 
al \sink sulla base di sincronizzazioni locali, il che significa che nel caso un pacchetto dal 
nodo $X$ al nodo $Y$ vada perso o sia danneggiato nesuno dei nodiche si trovano sull'hop path da 
$Y$ al \sink verrà informato della necessità di cambiare il proprio duty cycle, ed essi quindi 
non sprecheranno risorse inutilmente rimanendo attivi in un periodo in cui non potrebbero 
comunque ricevere altri dati. 


Va sottolineato che nel DMAC, quando un nodo riceve un pacchetto \texttt{more-to-send} esso non 
rimane in uno degli stati attivi nello slot immediatamente seguente, bensi esso entra in uno stato di inattività ma riducendone la durata a  
$3\mu$ per poi tornare nello stato di ricezione. Questa attesa è necessaria affinché il 
pacchetto abbia il tempo di propagarsi tra i nodi seguenti, senza che ci siano collisioni con i
pacchetti dei livelli precedenti. 
% pippa sul fatto che potebber essre sprecato un periodo
% pippa sul data prediction


\chapter{La piattaforma TinyOS}

\section{Un sistema operativo per WS}
Lo sviluppo della tecnologia dei sensori wireless pùò essere paragonato a quella delle 
piattaforme PC domestiche. Ad un aumento costante della potenza di calcolo si è accompagnato un 
aumento nella gamma di periferiche (memoria non volatile, attuatori, sensori di 
luce/calore/movimento etc\ldots) ed un aumento della disponibilità di tale hardware.
Esattamente come per l'informatica domestica, sono sorte quindi la possibilità e la necessità 
di gestire i
componenti ad un livello più alto di astrazione, esattamente come per i PC si è passati 
da sistemi operativi 
ad hoc scritti in assembly a strutture stratificate in linguaggi di livello più alto. 

TinyOS rappresenta appunto un sistema operativo "\emph{moderno}" per WS, che fornisce 
utili astrazioni per la realizzazione di applicazioni, ad un tempo rendendole più 
semplici da realizzare e facilmente portabili tra diversi modelli di sensore.

Tra le funzionalità che TinyOS offre ci sono
\begin{itemize}

\item{astrazione dei driver per sensori, radio, ed ogni altra periferica  }

\item{vari meccanismi per la concorrenza }

\item{gestione della memoria e dello scheduling}

\item{un linguaggio di sviluppo (NesC) che supporti direttamente tutto questo}
\end{itemize}

TinyOS è software open source, disponibili a tutti  e con una comunità in crescita.
Esso offre inoltre alcuni strumenti a corredo interessanti, tra i quali sono presenti 
simulatori, visualizzatori, database, ed interfacce con numerosi linguaggio di programmazione. 



\section{NesC un linguaggio per dispositivi wireless embedded}

Sebbene il C sia ormai lo standard de facto come \emph{system language} esso è per molti versi 
un linguaggio vecchio, che sebbene abbia conosciuto diverse revisioni mantiene comunque una 
netta mancanza per costrutti di alto livello. 
NesC è basato sul C, sia a livello sintattico che a livello semantico. 
In effetti il compilatore NesC è effettivamente implementato come un frontend per il noto compilatore multipiattaforma GCC \cite{nesc}.

NesC estende però il C in varie direzioni ortogonali, che rispecchiano da un lato le funzionalità
di TinyOS e dall'altro le necessità dell'hardware particolare su cui esso deve 
funzionare. 

\subsection{Task}
TinyOS fornisce alcune primitive per la concorrenza che sono replicate nel design di NesC.
Ogni dispositivo può avere in esecuzione differenti \emph{task}, i quali vengono attivati 
secondo un 
meccanismo di scheduling non preemptive, quindi funzionano finché la funzione associata non 
raggiunge un \texttt{return}. Si tratta di un meccanismo di concorrenza a stato condiviso in cui 
i task possono comunicare solamente tramite variabili condivise, in modo analogo a 
\emph{pthread} o ai thread in Java/.NET, con la differenza importante che ogni programma scritto in  NesC è soggetto ad 
un'analisi globale che è teoricamente in grado di individuare possibili race condition e 
condurre l'autore alla loro eliminazione, riducendo il numero di bug. 
Questo meccanismo no è però infallibile, e può sbagliare producendo false positive 
(eliminabili indicando esplicitamente al compilatore che non ci sono race condition) o non 
individuando dei problemi[[]]. i
Ogni task mantiene il controllo della CPU fino a che non termina, senza essere mai interrotto da un altro task, e non esiste un meccanismo di sincronizazione esplicita 
dei task in stile "\emph{join}".
Un task può però essere interrotto da un evento asincrono.


\subsection{Eventi}
Lo scheduler di TinyOS può comunque sempre decidere di interrompere il funzionamento di un task 
se esso riceve un evento hardware (preempting). 
Per modellare questi casi NesC offre il meccanismo degli eventi, 
che sono speciali funzioni annotate come tali e che vengono richiamate in numerosi 
casi, l'arrivo di un segnale radio, l'avvio di un timer, l'inizio della ricezione di dati da un sensore etc...
Gli eventi non sono necessariamente asincroni, e tipicamente eventi di bassa priorità (per esempio il segnalare che un pacchetto è stato inviato) non lo sono.
\`E possibile definire propri eventi prependendo la keyword \texttt{event} ad una qualsiasi 
funzione, a differenza dei task che possono essere applicati solamente a funzioni \texttt{void}.
Poiché un evento asincrono potrebbe interrompere una funzione in un punto qualsiasi della sua esecuzione, NesC offre un meccanismo per garantire che un blocco di codice venga eseguito in 
maniera atomica,  permettendo di annotare una qualsiasi variabile come \texttt{atomic} o 
di inserire un blocco di codice indicate come tale in maniera simile a \texttt{synchronized} 
in java.


 

\subsection{Componenti ed Interfacce}
TinyOS come molti altri SO usa e fornisce delle interfacce per rappresentare gli oggetti del 
sistema (layer di rete, driver etc...). 
Mentre però in molte piattaforme classiche (Win32, Linux, BSD) ciò è fatto informalmente 
usando il linguaggio C, NesC è stato esteso per supportare sintatticamente l'idea di 
programmazione a componenti. 
Un'interfaccia dichiara di fornire un certo numero di 
\begin{itemize}

\item{eventi, il che significa che un componente che usi l'interfaccia deve fornire appropriati
handler} 

\item{comandi, cioè procedure o funzioni che verranno chiamate dal componente che usa l'interfaccia}
\end{itemize}

Un componente può implementare una o più interfacce (o implementare un'interfaccia più volte 
con nomi diversi, il che fornisce una qualche similarità con la progrmmazione ad oggetti), 
ed è composto principalmente da due parti, una di configurazione 
(dichiarazione di componenti ed interfacce usati) ed una di implementazione.
La configurazione è il cuore della parte \emph{Component-Oriented} di NesC, in quanto è 
il punto in cui viene effettuata l'associazione tra componenti ed interfacce, indicato come 
\emph{wiring}, offrendo una grande flessibilità. 
La parte di implementazione contiene riferimento solamente ai nomi inhdicati nella configurazione
, rendendo facilmente sostituibili i componenti.
L'implementazione contiene poi ovviamente il codice di comandi ed eventi, e può contenere un 
certo numero di variabili globali accessibili da tutte le funzioni del componente. 

Per massimizzare il riuso e la semplicità di programmazione componenti ed interfacce possono 
essere parametrizzati, un qualsiasi valore può essere 
incluso in fase di configurazione effettuando una sorta di \emph{currying} dell'interfaccia. 
In versioni più recenti di NesC è possibile avere anche type parameter, ma con la versione della piattaforma usata in questa tesi ciò non è stato possibile. 


%[[ ed eventuali dichiarazioni 
%riguardo i rapporti tra determinate interfacce (è possibile dichiarare che il modulo 
%\texttt{RedBlackTree} equivale all'interfaccia \texttt{Dictionary} anche se nel primo non 
%c'è nessun  riferimento alla seconda);  ]]



\subsection{Staticità}

NesC è un linguaggio completamente statico, nel senso che la maggior parte delle attività 
possibili è fatta a compile time. Con ciò non si intende solo un semplice type checking sui 
moduli compilativi, ma anche una gestione statica della memoria (in realtà è possibile usare 
\texttt{malloc()} e simili ma a patto di essere molto cauti) e con l'intero call graph disponibile a compile time. 

NesC fa uso di \emph{whole program analisys and optimization} (WPA/WPO) per raggiungere alte
performance tramite ottimizzazioni interprocedurali, constant propagation, dead code 
elimination etc (ma esse sono possibili in via teorica teoricamente, al momento molto poco 
di ciò è implementato).
Allo stesso tempo grazie alla WPA esso puo offrire garanzie riguardo l'affidabilità dei 
programmi (l'individuazione di possibili race condition sui dati condivisi è possibile proprio 
in virtù di questo fatto).


\newcommand{\tos}{\texttt{TOSSIM} }

\section{\tos, un simulatore per PC}
\tos\cite{TOSSIM} è un simulatore per personal computer  in grado di far funzionare lo 
stesso codice NesC che è stato scritto per i dispositivi embedded. 
I vantaggi di questo approccio è che il codice può essere scritto, debuggato e testato su 
una normale macchina casalinga, e poi essere trasportato senza cambiamenti su un dispositivo 
reale. 
\tos è in sostanza una libreria che viene connessa in fasi di link con il codice NesC 
tradotto in codice C, e che fornisce il \texttt{main()} ed altro, producendo un 
eseguibile nativo, per ogni applicazione TinyOS.

\tos è in grado di accettare in input un modello delle probabilità di perdita di pacchetti 
tra due nodi qualunque, o di usare dei modelli teorici predefiniti, ma non comprende ne' 
informazioni topologiche, ne' modelli di alto livello, i quali possono però essere sempre 
definiti in termini di probabilità di perdita su un qualsiasi arco.
\newcommand{\tv}{\texttt{TinyViz}}
Allo scopo di definire questi modelli, sono stati creati vari strumenti, tra i quali 
\texttt{LossyBuilder}, un programma in grado di generare file di testo rappresentanti 
la distribuzione di una rete di nodi in topologia a griglia, e \tv.
\tv è in realtà un sistema molto più complesso, basato su un architettura a plugin. 

\tos fornisce un'interfaccia modellata sui meccanismi di TinyOS, cioè comandi ed eventi, 
che gli opermette di interoperare con dispositivi esterni, permettendo così l'implementazione in componenti separati di tutta una serie di funzionalità ad esempio l'analisi dei segnali, la visualizzazione di una topologia, l'iniezione di pacchetti radio e di informazioni per i sensori etc.. 
\tv è un ambiente grafico ralizzato in java che astrae i meccanismi di base di questa 
interazione con \tos esponendoli tramite un'interfaccia non molto complessa ad una serie 
di plugin caricabili a runtime.  
La distribuzione di TinyOS comprende un insieme variegato di plugin che 
però sono purtroppo in molti casi non mantenuti e non funzionano. Il codice di tinyviz è 
in generale non troppo ben tenuto. 
Durante la realizzazione di questa tesi è avvenuta una riscrittura di questo ambiente che lo ha 
portato ad essere fondato su jython\cite{tython}, cioè un interprete python per JVM, 
il che permette la realizzazione di semplici script (ma anche programmi complessi).
 

\chapter{L'implementazione}
\section{Visione d'insieme}
Per realizzare l'applicazione il codice è stato strutturato in due differenti moduli più 
una libreria elementare in \texttt{C} per la gestione di una coda.

Il primo modulo si occupa dell'individuazione delle informazioni relative alla topologia, 
mantenendo per ogni nodo informazioni sulla sua distanza dal \sink e su quale sia il prossimo 
nodo nel multihop path.  
Quando l'albero è stato mappato inizia il loop principale dei mote, che è una 
semplice macchina a stati finiti con tre stati implementata con degli \texttt{if/else}.
Il codice fa uso di una coda per i pacchetti da inoltrare implementata nel file \texttt{MyQueue.h}, realizzata tramite una semplice lista collegata.
Era nelle intenzioni di realizzare un componente \texttt{Queue} usando dei type parameter, 
il che avrebbe reso possibile il riuso dello stesso in situazioni in cui si dovessero gestire 
code composte da pacchetti differenti, ma NesC nella versione utilizata non permette di 
realizzare interfacce parametrizzate tramite tipi, e quindi sarebbe stato necessario ricorrere 
ad un approccio non type safe, ad esempio usando dei cast da e verso \texttt{void *}, ma ciò 
avrebbe a sua volta introdotto complicazioni derivanti dalla necessità di passare la dimensione 
della struttura ad ogni operazione, aggiungendo poca utilità a questa applicazione e portanto 
una complicazione inutile, quindi all'interno del codice si fa riferimento esplicito ai tipi 
definiti nel resto del programma (\texttt{DataMsg} definito in \texttt{DMac.h}).



\newcommand{\treedata}{\texttt{TreeData}}
\newcommand{\tree}{\texttt{Tree}}

\section{Il componente \treedata}
La mappatura dell'albero è affidata ad un componente apposito \tree, che implementa l'interfaccia
\texttt{StdControl} e ne definisce una sua, \treedata.
L'interfaccia \texttt{StdControl} è un'interfaccia generica per un componente NesC, che fornisce 
comandi per attivare o disattivare un componente, ed avviare operazioni specifiche.
L'attivazione di \tree porta all'attivazione del componente di rete, \texttt{GenericComm}, 
il quale fornisce implementazioni delle interfacce di basso livello per l'invio e la ricezione 
di pacchetti. 
Queste interfacce lavorano in termini di una struttura \texttt{TOS\_Msg} la quale possiede un 
campo dedicato al contenimento di una struttura definita dall'utente, la quale in questo
componente contiene solo due campi, uno contentente il numero sequenziale dell'hop count ed uno 
con l'indirizzo del mittente. 
Quando viene richiamato il comando \texttt{StdControl.start()} il modulo inizio la mappatura 
dell'albero seguendo un processo molto semplice, a partire dal \sink. 
Questo nodo invia un segnale broadcast indicando il suo indirizzo di rete ed il numero di hop 
necessari a raggiungerlo ($1$, per il \sink). Ogni nodo che riceve questo messaggio provvede 
poi ad inoltrarlo a sua volta, sempre come segnale broadcast, aggiornando le
informazioni su mittente ed hop count. 
Quando un nodo riceve un messaggio viene segnalato l'evento 
\texttt{ReceiveMsg.receive()}, ed è li che si trova la vera logica del componente. 
Infatti il codice si occupa di impostare appropriatamente delle variabili globali 
(a livello di componente) che rappresentano l'hop count ed il prossimo nodo nel percorso verso 
il \sink, ma solamente nel caso che il messaggio ricevuto indichi la possibilità di raggiungerlo
in un numero di hop minore rispetto a quello registrato precedentemente. 

Il Sink, dal canto suo, continua ad inviare pacchetti ad intervalli regolari (cioè ogni volta 
che viene segnalato \texttt{SinkTimer.fired()}, in modo da evitare eventuali errori dovuti alla 
perdita di pacchetti o a problemi di trasmissione.
Il processo continua fino a che il componente non viene fermato, tramite 
\texttt{StdControl.stop()}, ed è il codice in \texttt{DmacM.nc} che si occupa di questo.

Le informazioni immagazzinate da questo componente sono accessibili tramite i due comandi 
definiti nell'interfaccia \treedata, e cioè \texttt{getHopToSink()} e \texttt{getNextHopToSink()}. 
Alcune note aggiuntive su questa implementazione:
\begin{itemize}
\item{L'implementazione non specifica quale nodo sia il \sink, è il codice che usa questo 
componente che può decidere quale sia il nodo che deve iniziare la mappatura dell'albero, 
tramite \texttt{StdControl.start()}, il che rende il modulo più flessibile}

\item{In realtà l'albero tracciato in questo modo non implica che un nodo al livello $n$ sia in 
grado di inviare messaggi al livello $n-1$, perché è possibile che ci siano delle asimmetrie 
nelle capacità di invio/ricezione; \tos supporta questo tipo di topologie, in quanto si 
occupa solamente di percentuali di errore tra due archi generici, e gli archi $(a,b)$ e $(b,a)$ 
vengono considerati differenti. Per questa simulazione non ci siamo occupati di questo problema,
assumendo che se la comunicazione può avvenire in un verso possa funzionare anche nell'altro. 
D'altro canto sarebbe relativamente semplice cambiare una parte dell'implementazione del modulo \tree utilizzando un algoritmo di mappatura più corretto mantenendo comunque la stessa 
interfaccia.}

\item{In questo codice, ed anche nel codice del resto del programma, si può notare la presenza 
di una variabile di tipo \texttt{TOS\_Msg} che è dichiarata globalmente.
Ciò è necessario poiché il meccanismo di invio di un pacchetto radio è organizzato in due fasi, 
la prima viene attivata tramite il comando \texttt{SendMsg.send()}, che in realtà \emph{non} 
invia il messaggio ma lo mette in una coda di invio.
La seconda fase viene effettuata dal layer sottostante, che una volta inviato il pacchetto 
richiama l'evento \texttt{SendMsg.sendDone()}. 
Se quindi la variabile che rappresenta il messaggio fosse dichiarata come locale in 
\texttt{SinkTimer.fired()} essa verrebbe deallocata quando la funzione terminasse,  
ed al momento dell'effettivo invio il layer sottostante si troverebbe un riferimento 
ad una zona di memoria non valida. }
\end{itemize}

Infine, va detto che l'evento \texttt{SendMsg.sendDone()} viene richiamato passandogli un 
argomento che  dovrebbe indicare se l'invio è avvenuto correttamente o meno. 
Nel simulatore questo valore non è affidabile, in quanto il valore \texttt{SUCCESS}, di ovvio 
significato, è cablato nel codice senza alcuna condizione. 
Purtroppo sembra che in \tos siano state prese numerose scorciatoie di questo tipo, il che 
rende lo sviluppo usando il simulatore decisamente più problematico. 


\section{Il cuore dell'applicazione}
Il componente Dmac implementa l'algoritmo descritto in \cite{DMAC} sebbene in realtà lo faccia 
ad un livello più alto rispetto a quello corretto. Infatti andare a sostituire i layer di rete 
più bassi sul simulatore è complesso rispetto al farlo su un dispositivo reale, 
e sebbene esistano dei documenti sull'implementazione dello stack in alcuni particolari mote\cite{stackpdf} essi sono vecchi di oltre 3 anni e comunque non danno molte informazioni riguardo la
possibilità di implementare lo stesso meccanismo nel simulatore. 
D'altrodne non è stato neanche possibile trovare 
un'implementazione sostitutiva dei layer basilari di \tos da prendere come esempio. 
Sebbene quindi il codice sia algoritmicamente corretto e funzionante,
ci sono dei dettagli che non sono stati considerati, ad esempio il CRC, ed esso risulta 
subottimale per l'ovvia sovrapposizione delle due logiche. 
Il modulo fra uso di due timer, del componente \texttt{GenericComm}  che implementa le 
primitive di invio di messaggi, ed ovviamante del componente \tree. 
I due timer potrebbero in realtà essere sostituiti da un uno solo, ma sono stati separati 
per ottenere una maggiore chiarezza del codice.
Il ruolo del primo, \texttt{TreeTimer} è di controllare la durata del periodo necessario per
acquisire i dati sulla topologia dei nodi, al termine del quale il componente \tree, avviato 
nel momento in cui viene avviato il codice principale, viene fermato.
Ovviamente la durata di questo periodo dovrebbe essere tarata basandosi sulla topologia fisica 
dei dispositivi, sul loro numero e sulla reale frequenza di errore, ed è possibile farlo 
tramite una definizione nel file \texttt{Dmac.h}.
Il codice dell'evento \texttt{TreeTimer.fired()} si occupa anche di memorizzare i dati topologici
e di avviare il loop principale preparando il timer principale. 
Ogni volta che il timer principale scatta si effettua una transizione di stato e viene 
impostato un nuovo tempo di attesa prima che il timer segnali di nuovo l'evento. 
Il tempo di attesa è dipendente dallo stato del nodo, che è dato dall'unione di una variabile 
di tipo \texttt{enum}, \texttt{myState} e di un valore booleano, \texttt{moreToSend}. 
In teoria sarebbe stato possibile unire le due cose ottenendo un automa a stati finiti a 
5 stati, ma in assenza di vantaggi significativi si sarebbe aggiunta una complessità maggiore 
del codice. 

Come già detto in precedenza la correttezza del tutto è strettamente dipendente dalla sincronia 
nel funzionamento di tutti i mote. Piuttosto che implementare un intero sottosistema 
di sincronizzazione si è scelto di aggirare il problema supponendo che i nodi si fossero già 
sincronizzati, indicando al simulatorei di avviarli tutti insieme, o meglio in un intervallo di tempo abbastanza piccolo da essere trascurabile. 

\subsection{La coda di invio e \texttt{MIG}}
I messaggi ricevuti vengono mantenuti in una struttura del tipo implementato in
 \texttt{MyQueue.h},
basata su una coppia di strutture e su un meccanismo molto semplice di lista collegata. 
In teoria TinyOS non fornisce una primitiva per la funzione \texttt{malloc()} usata in questo 
file, ne' garantisce una gestione corretta dell'heap, ma si limita a inoltrare la richiesta 
alla libreria sottostante.  Nel nostro caso però sappiamo che il sistema operativo sottostante 
(Unix-like o win32) offre questo meccanismo per cui se ne può fare uso tranquillamente. 
E' mia convinzione che dato che la gestione della memoria dinamica è demandata solamente a 
questo singolo pezzo dell'applicazione non dovrebbero esserci problemi neanche con un porting 
diretto, ma in alternativa è possibile sostituire facilmente il codice con uno che utilizzi un 
array statico, in quanto l'implementazione della coda è completamente opaca rispetto al 
resto del codice. 
L'uso esplicito di una coda per i messaggi in questo componente porta con se anche un 
vantaggio importante in termini di semplicità di testing dell'applicazione, che a prima vista 
potrebbe non essere evidente, collegati al funzionamento del protocollo. 

Va premesso che per permettere l'interazione con i mote \tos viene fornito con una suite di 
strumenti tra cui due mirati specificamente all'invio o ricezione di dati di test al simulatore. 
Il primo di essi, \texttt{SerialForwarder}, è un'applicazione java che si limita a fare da ponte 
tra il canale di comunicazione (reale o virtuale) e generiche applicazioni nel computer, mentre 
il secondo, \texttt{MIG} è uno strumento da riga di comando che dovrebbe teoricamente 
permettere di trasformare la definizione di una \texttt{struct} che definisce il pacchetto, 
necessaria per l'uso di \texttt{SendMsg} e \texttt{ReceiveMsg}, in un file \texttt{Java} che è 
possibile inviare con le funzionalità del package \texttt{net.tinyos} o tramite l'interprete 
python integrato in \tv. 
La struttura che rappresenta il pacchetto è composta da un campo di tipo \texttt{enum pkt\_type}
che rappresenta il fatto che un pacchetto sia di tipo \req o \ack, di un campo \texttt{bool} 
per la flag \texttt{more-to-send} e di due campi da due byte che indicano mittente e dati.

Purtroppo, \texttt{MIG} sembra non essere in grado di produrre del codice appropriato per questo tipo di pacchetto, producendo valori senza significato per praticamente qualsiasi 
campo della struttura, il che ha richiesto la scrittura da zero di una classe appropriata. 
 

Il vero problema è però di natura ancora più banale: affinché l'algoritmo funzioni correttamente 
i nodi devono scartare un pacchetto ricevuto nello stato di inattività e quindi diventa scomodo
cercare di cogliere al volo il breve periodo di ricezione. 
Usando la coda di messaggi è invece molto semplice far si che dopo un certo periodo di tempo 
i dati vengano introdotti in essa facendo si che il nodo si trovi, al seguente stato di invio, 
nella condizione di dover inoltrare i dati permettendo una simulazione molto più agevole. 


\subsection{L'inoltro delle richieste}
All'entrata nello stato di invio viene richiamato il task appropriato, 
\texttt{forwardReq()}, il cui significato è ovvio.
Questo task si occupa di inoltrare il messaggio usando la primitiva di invio 
\texttt{SendMsg.send()},
ma non \emph{non} estrae l'elemento in cima alla coda in quanto questo comando si limita 
ad inserire il messaggio in una coda di pacchetti da inviare, 
e riporta solamente il successo di questa operazione 
e non il successo dell'invio, compito demandato all'evento \texttt{SendMsg.sendDone()}.
Tra l'altro sembrerebbe che in realtà questa coda di invio sia limitata ad un singolo slot, 
in quanto dalle simulazioni sembra che sia impossibile ottenere il successo del comando \texttt{send} se non è stato ancora segnalato \texttt{sendDone} per il pacchetto accodato in precedenza. 


D'altronde anche se il messaggio fosse inviato correttamente causando la segnalazione di 
quest'ultimo con un valore \texttt{SUCCESS}  non ci sarebbero garanzie sulla ricezione da 
parte del prossimo nodo. Dunque per eliminare un messaggio dalla coda aspettiamo di ricevere 
un pacchetto di \ack, sapendo che esso sarà per forza relativo all'ultimo nostro pacchetto 
inviato, giacché sappiamo che ne viene inviato solamente uno per ogni slot. 

Nel caso dunque non venga ricevuto un \ack il pacchetto rimane nella coda di invio in attesa 
del prossimo slot libero. \`E certamente possibile che un nodo riceva un pacchetto di tipo \req 
ma il relativo pacchetto di \ack vada perso, il che introdurrebbe dei duplicati nel ciclo, 
ma questo è un problema che è semplice affrontare aggiungendo dei numeri sequenziali ad un 
livello più alto dello stack di comunicazione. 

Va notato che per questa implementazione i nodi al livello $n$ inviano sempre i propri 
pacchetti al nodo padre nell'albero tracciato inizialmente. 
Pre rendere questo MAC del tutto generico rispetto all'implementazione di meccanismi di 
routing sovrastanti sarebbe sufficiente cambiare \texttt{forwardReq()} in modo che essa 
non faccia riferimento alla variabile  \texttt{nextNode} ma ad un generico comando 
\texttt{route()} che scelga il nodo seguente secondo un meccanismo qualsiasi.  

\subsection{Invio e ricezione di \ack}
La funzione \texttt{sendAck()} si occupa di impostare valori appropriati nel pacchetto di \ack 
e di inviare il pacchetto tramite le primitive di \texttt{SendMsg}. 

Il destinatario del pacchetto \ack viene inviato basandosi sul valore della variabile 
globale \texttt{lastSender}, poiché i task non accettano argomenti in input ne' 
restituiscono valori. 
A prima vista potrebbe sembrare che questo meccanismo introduca una race condition nel 
caso l'evento \texttt{ReceiveMsg.receive()} venga segnalato più volte prima dell'avvio 
di \texttt{sendAck()},
ma in realtà non è così. L'evento \texttt{sendDone()} non è un evento hardware, e quindi non 
è dichiarato come \emph{asincrono} (teoricamente qualsiasi evento può essere dichiarato come asincrono, ma è convenzione non farlo per eventi non hardware in quanto rende più difficile l'analisi del programma) il che significa che esso non interromperà mai l'esecuzione di un altro evento o task. 
I task vengono eseguiti in rigido ordine FIFO, il che significa che un task $B$ posto nella coda
di scheduling da un task $A$ verrà eseguito sempre dopo di esso a meno di interruzioni asincrone.
Ciò fa si che la variabile \texttt{lastSender} funzioni implicitamente come una coda senza 
bisogno di meccanismi più complessi e dispendiosi. 

La funzione \texttt{gotAck()} è semplicissima, limitandosi ad eliminare il primo elemento 
nella coda, quando esiste la certezza che questo è stato ricevuto. 

\subsection{Il problema dei pacchetti multipli}
Secondo il documento originale un nodo dovrebbe intensificare il proprio duty cycle in due casi
\begin{itemize}
\item{se esso riceve un messaggio che indichi l'intenzione del nodo precedente di inviare altri 
pacchetti}
\item{se essendo lui intenzionato a inviare altri pacchetti esso riceve un \ack che indica che il nodo seguente è pronto ad intensificare il proprio duty cycle}
\end{itemize}
\`la seconda condizione è necessaria affinché un nodo non cominci ad intensificare il proprio 
ritmo di funzionamento senza che il nodo seguente l'abbia fatto, sprecando cicli di attività e 
quindi batteria. Ogni nodo però che si trovi lungo l'hop path è però forzato dalla prima 
condizione a farlo nel momento in cui riceve un messaggio con la flag \texttt{more-to-send} 
attiva, il che significa che l'unico nodo che deve prendere in considerazione la seconda 
condizione è il nodo che effettua la rilevazione dei dati e che si appresta ad inoltrarli. 
In questa implentazione però la seconda regola non è stata presa in considerazione, in quanto 
essa avrebbe richiesto l'utilizzo di una ulteriore serie di componenti e strumenti dedicati alla 
raccolta di dati sia a livello di codice che di simulazione.

L'aggiunta della logica per controllare la seconda condizione sarebbe d'altronde molto 
semplice, ed il codice è strutturato in modo da renderlo possibile.
Si tratterebbe, sostanzialmente, di aggiungere alla funzione \texttt{gotAck()} un controllo sul 
fatto che si stia attendendo l'arrivo di un \ack per la propria richiesta di aumentare il ritmo,
possibile tramite una variabile globale o tramite un comando apposito delegato al componente di 
raccolta dei dati.  

Un problema che non è trattato chiaramente non paper originale\cite{DMAC} è quello di come riallineare il funzionamento dei mote dopo un burst di pacchetti. 
Infatti un nodo che si trovasse su differenti percorsi verso il \sink dopo un intensificazione 
del duty cycle si troverebbe si ancora sincronizzato con i nodi su quel percorso, ma sarebbe 
fuori sincronia rispetto agli altri path. 
Non è stato possibile ricevere chiarimenti a riguardo dagli autori originali, e quindi è stata 
adottata una soluzione che sembrerebbe essere sufficiente: quando un nodo esce dal ritmo 
intensificato esso si riallinea ai tempi originali entrando in uno stato di inattività di 
lunghezza variabile.
 

\section{La simulazione}

\tos non possiede un'interfaccia grafica, ma si limita a fornire delle funzionalità in stile 
\texttt{printf} per mettere a schermo delle stringhe di debug. 
Ogni stringa di debug è associata ad una categoria appropriata (SIM, RADIO, LED etc\ldots), 
ed il simulatore fa uso della variabile d'ambiente \texttt{DBG} per decidere quale mostrare. 

Per rendere più semplice la simulazione esiste \tv, che non solo permette di avere una 
rappresentazione grafica, ma tramite l'interprete python integrato nell'ultima versione 
permette anche di scrivere semplici script per automatizzare l'accensione/spegnimento dei nodi,
le variazioni nelle percentuali di perdita, l'immissione di pacchetti e molto altro. 
Anche senza usare script in python è possibile automatizzare le simulazioni utilizzando un file 
di autorun.
Nell'utilizzo di \tv purtroppo sono stati incontrati molti problemi:
\begin{itemize}
\item{I documenti che indicano come utilizzare l'interprete interattivo sono obsoleti e 
praticamente tutte le gerarchie dei moduli sono differenti.}
\item{Per poter impostare dei valori di debug nel file di autorun è necessario  
cambiare il codice sorgente di \tv altrimenti al simulazione nell'ambiente \emph{cygwin} 
fallirà sempre per l'erroneo uso di \texttt{Runtime.exec}. Abbiamo inviato una patch 
agli autori per risolvere questo problema}
\item{Tra i plugin  che abbiamo utilizzato c'è \texttt{DirectedGraph}, un plugin che fa uso 
di stringhe di debug formattate secondo una particolare sintassi per rappresentare informazioni 
grafiche. Questo plugin \emph{non può funzionare} out of the box in quanto invece di esserci 
una assegnazione ad una variabile globale si trova una ridichiarazione, il che fa si che 
ad ogni accesso alla variabile globale venga generata un'eccezione.}
\item{La classe che si occupa di analizzare il file di autorun noon è stata aggiornata insieme 
al resto del codice, il che fa si che sia possibile impostare da riga di comando alcuni 
argomenti mentre è impossibile farlo con il file di configurazione.}
\item{Infine, sembra che \tv cambi sempre in qualche modo la definizione della topologia senza 
offrire all'utente la possibilità di ripetere una simulazione}
\end{itemize}

Per tutti questi motivi si è preferito generalmente usare il simulatore in modalità testuale, 
il che permette oltretutto di effettuare dei test automatizzati semplicemente salvandone
 l'output e confrontandolo con quello di una precedente simulazione. 


\chapter{Conclusioni}
Le simulazioni effettuate con i nodi disposti in griglie $5x5$, $7x7$ e $10x10$ mostrano il
comportamento atteso, sebbene esse subiscano dei lievi peggioramenti con il diminuire della 
lunghezza degli slot, facendo aumentare le collisioni.
L'impressione è che tale peggioramento sia dovuto all'implementazione del simulatore 
che impiega un certo tempo per segnalare i numerosi eventi in reti complesse. 
L'abbassamento dell'intervallo di inattività porta ad un aumento del throughput 
a scapito dell'efficienza energetica, e la scelta di una durata di $18\mu$ per questo periodo 
è stata dettata dalle informazioni presenti in \cite{DMAC} riguardo i test nell'ambiente 
NS2, mentre non sembra esserci una motivazione a priori. L'impresssione è che questo valore 
possa essere tranquillamente tarato in ogni rete ad hoc in modo da raggiungere compromessi 
differenti con il risparmi energetico. 

Le simulazioni sono state effettuate usando differenti valori per le probabilità di perdita 
dei pacchetti dimostrando che la percentuale di pacchetti persi è direttamente collegata  
alla probabilità di perdita il che fa supporre che i problemi relativi alla contesa del 
canale siano minimizzati come ci si aspetta. 


Il prossimo passo nello studio di questo protocollo sarebbe quello di effettuare il 
porting dell'algoritmo al livello corretto dello stack, e di effettuare nuovi test in questo 
ambito, per poi verificare su hardware reale la validità dei meccanismi. 

\appendix
%\begin{lstlisting}
\lstset{
%  stringspaces=false,
  basicstyle=\small,
%  language=C,
%  basicstyle=\ttfamily,
  numbers=left, 
  stepnumber=5, 
  numbersep=8pt,
%  frame=single,
%  numberblanklines=false,
  frame=L,
%  xleftmargin=10pt,
%  xrightmargin=20pt
  }
%\addcontentsline{toc}{chapter}{Codice del componente DMac}
\chapter{Codice del componente DMac}
\section{DMac.h}
\lstinputlisting{DMac.h}
\section{DMac.nc}
\lstinputlisting{DMac.nc}
\section{DMacM.nc}
\lstinputlisting{DMac.nc}

%%\chapter{Codice del componente Tree}
%\section{TreeData.nc}
%\lstinputlisting{lib/TreeData.nc}
%\section{Tree.h}
%\lstinputlisting{lib/Tree.h}
%\section{Tree.nc}
%\lstinputlisting{lib/Tree.nc}
%\section{TreeM.nc}
%\lstinputlisting{lib/TreeM.nc}

%\end{lstlisting}

\backmatter
\begin{thebibliography}{99}
\bibitem{DMAC} "An Adaptive Energy-Efficient and Low-Latency MAC for Data Gathering in Sensor Networks", \emph{G Lu, B Krishnamachari, C Raghavendra - Workshop on Energy-Efficient Wireless Communications, 2004} 
\bibitem{TOSSIM} "TOSSIM: Accurate and Scalable Simulation of Entire TinyOS Applications", \emph{Philip Levis, Nelson Lee, Matt Welsh, and David Culler. In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys 2003)}.  
\bibitem{SMAC} smac
\bibitem{TMAC} tmac
\bibitem{nesc} "The nesC Language: A Holistic Approach to Networked Embedded Systems", \emph{David Gay, Phil Levis, Rob von Behren, Matt Welsh, Eric Brewer, and David Culler. Proceedings of Programming Language Design and Implementation (PLDI) 2003, June 2003}.
\bibitem{tython} "Tython: A Dynamic Simulation Environment for Sensor Networks", \emph{Michael Demmer and Phil Levis}
\end{thebibliography}
\end{document}

