% vim: encoding=utf-8
% vim: fileencoding=utf-8
\documentclass[pdftex,12pt,a4paper,italian,openany]{book}
\usepackage[italian]{babel}
%è safe metterlo a 1.6, con 13 pagine arrivo a 16
\linespread{1.4}
%\renewcommand{\baselinestretch}{1.6}
\usepackage[utf8]{inputenc}
\usepackage{newcent}
\usepackage{fancyhdr}



\begin{document}
%\maketitle
\newlength{\centeroffset}
\setlength{\centeroffset}{-0.5\oddsidemargin}
\addtolength{\centeroffset}{0.5\evensidemargin}
\thispagestyle{empty}
%\vspace*{\stretch{1}}
\noindent\hspace*{\centeroffset}\makebox[0pt][l]{\begin{minipage}{\textwidth}
\flushright
{\fontfamily{helvet}
  {\Huge\bfseries Implementazione di un MAC energy-efficient per reti di sensori wireless}
  \noindent\rule[-1ex]{\textwidth}{5pt}\\[2.5ex]
  \flushright
  {\bfseries\Large Gabriele Renzi\\[1.5ex]
  Anno Accademico 2004/2005}
}
\end{minipage}}


\pagestyle{fancy}

\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\fancyhf{} % rimuove l’attuale contenuto dell’intestazione
             % e del pi\‘e di pagina
\fancyhead[LE,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\fancyhead[RE]{\bfseries\leftmark}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{0.5pt} % riserva spazio per la linea
\fancypagestyle{plain}{%
    \fancyhead{} % ignora, nello stile plain, le intestazioni
    \renewcommand{\headrulewidth}{0pt} % e la linea
}
\newcommand{\sink}[0]{\emph{Sink}}

\chapter{Introduzione}
L'intento della tesi è l'implementazione di un protocollo MAC appositamente progettato per 
rispettare i vincoli imposti da una particolare tipologia di reti wireless, le reti di sensori.
Una Wireless Sensor Network (WSN) è composta da un gran numero di dispositivi molto semplici, 
con limitate risorse computazionali e dotati di strumentazione per rilevare eventi (movimento,
temperatura, video etc), per effettuare semplici elaborazioni e di eventuali meccanismi per 
inteagire con l'ambiente e per comunicare via radio. 
Un sensore infatti non ha le risorse sufficienti a fornire un'elaborazione complessa delle 
informazioni, e quindi una WSN viene organizzata come un albero nel quale i nodi e le foglie 
raccolgono i dati e li inoltrano verso la radice dell'albero, verso un nodo denominato 
\sink, il quale sarà  connesso ad un elaboratore in grado di gestire le informazioni 
raccolte in modo utile.
Il protocollo implementato per questa tesi, DMAC\cite{DMAC}, è appositamente pensato per una 
topologia di questo genere, e cerca di sfruttare delle euristiche per limitare sia la 
possibilità di errore nella trasmissione, sia il consumo energetico, garantendo comunque una 
bassa latenza.
Per l'implementazione del protocollo è stata utilizzata la piattaforma TinyOS, un ambiente per 
o sviluppo di applicazioni per dispositivi embedded che comprende un semplice sistema operativo
, un linguaggio di programmazione, e vari strumenti come simulatore, visualizzatori grafici, 
ambienti di scripting e molto altro. 
%\subsection{Obiettivi  della tesi}

\tableofcontents
\chapter{Il protocollo DMAC}
\section{I problemi delle reti di sensori}
In una topologia come quella appena descritta, è evidente che la parte più rilevante del 
traffico è costituita dal flusso di pacchetti verso il \sink, mentre le informazioni 
trasmesse nel verso opposto sono limitate a rari pacchetti di controllo.

I punti principali presi in considerazione dagli autori di DMAC sono
\begin{itemize}

\item \emph{latenza}, in alcune situazione, ad esempio la rilevazione in ambito medicale o 
la videosorveglianza, è importante che le informazioni si propaghino velocemente dal nodo che le 
rileva fino al Sink
\item \emph{throughput}, applicazioni differenti possono avere necessità  di approcci differenti\ldots

\item \emph{energia}, i sensori sono dispositivi a batterie, ed in configurazioni in cui il 
numero di questi dispositivi è molto alto non è fattibile la sostituzione/ricarica ad 
intervalli freguenti

\end{itemize}

Il punto principale da cui parte l'analisi del DMAC è l'energia, in quanto si tratta di un 
vincolo particolarmente importante. DMAC, come già altri protocolli\cite{SMAC}\cite{TMAC} 
progettati in precedenza, parte dalla 
considerazione che il traffico in una WSN è molto leggero per la maggior parte del tempo, e 
che quindi è 
possibile ed auspicabile che i nodi non coinvolti nel trasporto di dati rimangano spenti quanto più possibile, in modo da risparmiare energia. 
Questo approccio è in contrasto però con l'intento di massimizzare latenza e throughput, 
perché ogni nodo che si trovi a più di un hop dal \sink dovrà attendere che il nodo successivo 
nel suo percorso entri in uno stato attivo. Questo approccio non sembra quindi essere in grado 
di scalare a reti con molti nodi. 
Un alternativa è quella di mettere in nodi uno stato di \emph{power saving} la 
maggior parte del tempo e di portarli in uno stato attivo quando ricevono una richiesta di 
comunicazione, ma lo spreco di energia in questo approccio è comunque molto maggiore di quello 
relativo ad uno stato di spegnimento effettivo. 
\section{Staggered wakeup nel DMAC}
Il protocollo DMAC utilizza un meccanismo di scheduling a tre stati dei nodi, 
introducendo però un meccanismo di \emph{staggered wakeup} per cui i nodi che si trovano ad un 
hopcount maggiore dal \sink entrano nel ciclo di scheduling prima di quelli più vicini.
Questo approccio ha numerosi vantaggi, anzitutto il tempo di attesa per il forwarding di un
pacchetto è molto limitato, perché quando un nodo si trova in una fase attiva il prossimo mote 
che si trova nel suo percorso di routing verso il \sink sarà anch'esso attivo, e lo stesso 
ricorsivamente fino al source. 
\`E facile notare che un nodo che si trovi distante dall'azione resterà spento finché il 
pacchetto non gli si avvicina, con un notevole risparmio energetico.
Allo stesso tempo, il fatto che il pacchetto si propaghi in modo "lineare" permette di far si 
che tutti i nodi nel percorso verso il Sink siano in grado di correggere tempestivamente il loro 
scheduling se necessario, mentre i nodi non coinvolti nella trasmissione possono mantenere il 
loro ciclo di attivazione/spegnimento originario. 


\section{Stati nel DMAC}
Un problema che rimane è però la contesa del canale, anche se ovviamente il fatto che livelli 
differenti si attivino in momenti differenti riduce le dimensioni del problema.
Per far si che il messaggio arrivi correttamente e che le interferenze tra i differenti 
mote siano minimizzate, ognuno di essi può essere in tre differenti stati, suddividendo il 
periodo di funzionamento attivo in una coppia di periodi di ricezione ed invio. 

Nello stato di ricezione un nodo attende di ricevere un pacchetto, ed in caso questo accada 
esso ne manda uno di ACK al mittente. Il nodo ricevente \emph{non inoltrerà} i dati in questa 
fase ma li immagazzinerà in una coda fino a che non si trovi nel suo stato di invio. 
Ovviamente un nodo nello stato di invio non fa altro che inoltrare un pacchetto ed attendere un 
\texttt{ACK}. 

Come già detto è evidente che un nodo ad $n$ hop dal sink si troverà in uno stato di invio 
quando il nodo ad $n-1$ hop si trova in stato di ricezione. 
Nel caso che l'\texttt{ACK}  non venga ricevuto il pacchetto rimane nella coda e 
verrà inviato nel prossimo slot di invio, aggiungendo delle opportune regole di drop nel caso 
la trasmissione fallisca ripetutamente. 
Nel periodo di inattività i nodi spengono completamente la radio, e quindi sono isolati dalle 
trasmissioni, ma l'organizzazione temporale fa si che essi non abbiano comunque la possibilità 
di ricevere dati in questo periodo. 

I periodi di invio e ricezione hanno una stessa durata $\mu$ che deve essere lunga abbastanza 
affinché un pacchetto possa essere inviato e ricevuto, e ciò sia possibile anche per il 
suo \texttt{ACK}. 
 
Dunque ad ogni tempo $t$ teoricamente saranno solamente i nodi ad un certo livello a 
trasmettere, limitando la contesa per il canale. 

Il periodo di sleep ha una durata nettamente maggiore del periodo attivo, circa $18\mu$ [[]], a meno di \emph{burst} di pacchetti, come vedremo in seguito.
Un meccanismo di questo tipo ha bisogno evidentemente di una sincronizzazione molto precisa, ma 
esistono algoritmi validi che permettono di portare l'errore di sincronizzazione ad un millesimo 
del tempo $\mu$, quindi questo non rappresenta un problema. 

\section{Adattatività del DMAC}
Nella maggior parte delle WSN è probabile che un nodo che raccolga informazioni attraversi dei
periodi di \emph{burst} in cui esso ha parecchie informazioni da inoltrare, e si può notare che 
con il meccanismo appena descritto un'informazione che abbia bisopgno di due pacchetti avrebbe 
bisogno di almen 20 unità di tempo piuttosto che di 2 (il caso in cui i nodi fossero 
costantemente attivi) [[]], il che significa aumentare notevolmente la latenza della rete. 
Il protocollo prevede quindi dei meccanismi di autoregolazione del duty cycle basati su una flag 
\texttt{more-to-send} presente nell'header dei pacchetti.

Se un nodo ha diversi pacchetti da spedire oppure se ha ricevuto un pacchetto con questa flag
già impostata, esso imposterà la flag nei pacchetti in uscita in modo in modo da indicare al 
nodo seguente che ci sono altri dati in arrivo, e che esso dovrà prepararsi a riceverli. 
Il meccanismo è chiaramente ricorsivo e fa si che l'informazione si propaghi fino al Sink 
sulla base di sincronizzazioni locali, il che significa che nel caso un pacchetto dal nodo $X$ 
al nodo $Y$ vada perso o sia danneggiato nesuno dei nodi da $Y$ al Sink verrà informato della necessità di  cambiare il proprio duty cycle, il che permette di evitare sprechi di risorse 
aggiuntivi.

Va sottolineato che nel DMAC, quando un nodo riceve un pacchetto \texttt{more-to-send} esso non 
rimane attivo per il prossimo slot, bensi riduce il suo tempo di inattivita a $3\mu$ per poi tornare nello stato di ricezione. Questa attesa è necessaria affinché il pacchetto abbia il tempo di propagarsi tra i nodi seguenti, senza che ci siano collisioni con i pacchetti dei livelli precedenti. 
% pippa sul fatto che potebber essre sprecato un periodo
% pippa sul data prediction


\chapter{La piattaforma TinyOS}

\section{Un sistema operativo per WS}
Lo sviluppo della tecnologia dei sensori wireless pùò essere paragonato a quella delle 
piattaforme PC domestiche. Ad un aumento costante della potenza di calcolo si è accompagnato un 
aumento nella disponibilità di periferiche (memoria non volatile, attuatori, sensori di 
luce/calore/movimento etc\ldots). \`E sorta quindi la possibilità di gestire i coponenti ad un 
livello più alto di astrazione, esattamente come per i PC si è passati da sistemi operativi 
ad hoc scritti in assembly a strutture stratificate in linguaggi di livello più alto. 

TinyOS rappresenta appunto un sistema operativo "\emph{moderno}" per WS, che fornisce 
utili astrazioni per la realizzazione di applicazioni, ad un tempo rendendole più 
semplici da realizzare e facilmente portabili tra diversi modelli di sensore.

Tra le funzionalità che TinyOS offre ci sono
\begin{itemize}

\item{Astrazione dei driver per sensori, radio, ed ogni altra periferica  }

\item{Concorrenza (threading a stato condiviso}

\item{Gestione della memoria e dello scheduling}

\item{Un linguaggio di sviluppo (NesC) che supporti direttamente tutto questo}
\end{itemize}


\section{NesC un linguaggio per sensori}

Sebbene il C sia ormai lo standard de facto come \emph{system language} esso è per molti versi 
un linguaggio vecchio, che sebbene abbia conosciuto diverse revisioni mantiene comunque una 
netta mancanza per costrutti di alto livello. 
NesC è basato sul C, sia a livello sintattico che a livello semantico. 
In effetti il compilatore NesC è effettivamente implementato come un frontend per GCC [[ ]].

NesC estende però il C in varie direzioni ortogonali, che rispecchiano da un lato le funzionalità
sel SO sottostante e dall'altro le necessità dell'hardware particolare su cui esso deve funzionare. 

\subsection{Concorrenza}
TinyOS fornisce alcune primitive per la concorrenza che sono replicate nel design di NesC.
Ogni mote può avere in esecuzione differenti \emph{task}, i quali vengono attivati secondo un 
meccanismo di scheduling non preemptive, quindi funzionano finché la funzione associata non 
raggiunge un \texttt{return}. Si tratta di un meccanismo di concorrenza a stato condiviso in cui 
i task possono comunicare solamente tramite variabili globali, com \emph{pthread} o i thread in 
Java, ma il compilatore è in grado di determinare staticamente la possibilità di race condition 
(sebbene possa sbagliare). Va notato che non esistono meccanismi di sincronizazione esplicita 
dei task (nessun "\emph{join}").

\subsection{Eventi}
I task possono essere attivati da qualunque punto del programma, ed in particolare è possibile 
far si che essi vengano avviati quando accade qualcosa di rilevante. 
TinyOS e NesC forniscono allo sviluppatore gli eventi. Praticamente ogni cosa può essere 
rappresentata da un evento, l'arrivo di un segnale radio, l'avvio di un timer, l'inizio della ricezione di dati da un sensore etc...
 

\subsection{Componenti ed Interfacce}
TinyOS come molti altri SO usa e fornisce delle interfacce per rappresentare gli oggetti del 
sistema (layer di rete, driver etc...). 
Mentre però questo in molte piattaforme classiche (Win32, Linux, BSD) ciò è fatto informalmente 
usando il linguaggio C, NesC è stato esteso per supportare sintatticamente l'idea di 
programmazione a componenti. 
Un'interfaccia dichiara di fornire un certo numero di 
\begin{itemize}

\item{eventi, il che significa che un componente che usi l'interfaccia deve fornire appropriati
handler} 

\item{comandi, cioè procedure o funzioni che verranno chiamate dal componente che usa l'interfaccia}
\end{itemize}

Un componente può implementare una o più interfacce (o implementare un'interfaccia più volte 
con nomi diversi), ed è composto principalmente da due parti, una di configurazione 
(dichiarazione di componenti ed interfacce usati) ed una di implementazione.
La configurazione è il cuore della parte Component-Oriented di NesC, in quanto è l'unico punto 
in cui si effettua il \emph{wiring} tra differenti componenti, offrendo una grande flessibilità.
Componenti ed interfacce, infine possono essere parametrizzati, un qualsiasi valore può essere 
incluso durante il wiring effettaundo una sorta di \emph{currying} dell'interfaccia. 
In versioni più recenti di NesC è possibile avere anche type parameter, ma in questa tesi  
il problema è stato aggirato [[]]


[[ ed eventuali dichiarazioni 
riguardo i rapporti tra determinate interfacce (è possibile dichiarare che il modulo 
\texttt{RedBlackTree} equivale all'interfaccia \texttt{Dictionary} anche se nel primo non 
c'è nessun  riferimento alla seconda);  ]]



\subsection{Staticità}

NesC è un linguaggio completamente statico, nel senso che la maggior parte delle attività 
possibili è fatta a compile time. Con ciò non si intende solo un semplice type checking sui 
moduli compilativi, ma anche una gestione statica della memoria (in realtà è possibile usare 
\texttt{malloc()} e simili ma a patto di essere molto cauti) e con l'intero call graph disponibile a compile time. 

NesC fa uso di \emph{whole program analisys and optimization} (WPA/WPO) per raggiungere alte 
performance tramite ottimizzazioni interprocedurali (teoricamente è possibile aggiungerne altre 
alla pipeline ma al momento esse non sono implementate).
Allo stesso tempo grazie alla WPA esso puo offrire garanzie riguardo l'affidabilità dei 
programmi (il compilatore è in grado di individuare possibili \emph{race condition} sui dati globali).


\chapter{L'implementazione}
Il file 


\begin{thebibliography}{99}
\bibitem{DMAC} An energy bla bla
\bibitem{foo} ofoo foo
\end{thebibliography}
\end{document}

